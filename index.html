<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Variscient</title>
<link href="https://unpkg.com/tabulator-tables@5.6.1/dist/css/tabulator_midnight.min.css" rel="stylesheet">
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<script src="https://unpkg.com/tabulator-tables@5.6.1/dist/js/tabulator.min.js"></script>
<style>
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface2: #242736;
    --border: #2e3142;
    --text: #e0e0e8;
    --text-dim: #888899;
    --accent: #5b8def;
    --accent-hover: #7aa5ff;
    --syn: #527F91;
    --nonsyn: #a0392d;
    --intergenic: #888899;
    --unknown: #888899;
    --danger: #e05555;
    --success: #55b87a;
  }
  html[data-theme="colorblind"] {
    --syn: #0072B2;
    --nonsyn: #D55E00;
    --intergenic: #F0E442;
  }
  html[data-theme="colorblind"] .type-intergenic { color: #1a1d27; }
  .cb-toggle {
    position: fixed; top: 10px; right: 16px; z-index: 999;
    background: var(--surface2); border: 1px solid var(--border);
    color: var(--text-dim); border-radius: 5px; padding: 4px 10px;
    cursor: pointer; font-size: 11px; transition: all 0.15s;
    display: inline-flex; align-items: center; gap: 4px;
  }
  .cb-toggle:hover { border-color: var(--accent); color: var(--text); }
  .cb-toggle.active { border-color: var(--accent); color: var(--accent); }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
    background: var(--bg);
    color: var(--text);
    line-height: 1.5;
    overflow-x: hidden;
  }
  .container { max-width: 1600px; margin: 0 auto; padding: 16px 24px; }

  .header {
    display: flex; flex-direction: column; align-items: center; gap: 8px;
    padding: 16px 0; border-bottom: 1px solid var(--border); margin-bottom: 16px;
    text-align: center;
  }
  .header h1 { font-size: 36px; font-weight: 700; text-transform: uppercase; letter-spacing: 4px; }
  .header .subtitle { color: var(--text-dim); font-size: 13px; }

  /* Reference bar */
  .ref-bar {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 8px; padding: 14px 18px; margin-bottom: 16px;
    display: flex; flex-wrap: wrap; gap: 12px; align-items: flex-end;
  }
  .ref-bar .ref-group { display: flex; flex-direction: column; gap: 4px; }
  .ref-bar label { font-size: 11px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; }
  .ref-bar input[type="text"] {
    background: var(--surface2); border: 1px solid var(--border);
    color: var(--text); border-radius: 5px; padding: 6px 10px;
    font-size: 13px; outline: none; width: 200px;
  }
  .ref-bar input[type="text"]:focus { border-color: var(--accent); }
  .ref-bar .ref-file-label {
    background: var(--surface2); border: 1px solid var(--border);
    color: var(--text-dim); border-radius: 5px; padding: 6px 12px;
    font-size: 12px; cursor: pointer; transition: all 0.15s;
    display: inline-flex; align-items: center; gap: 6px;
  }
  .ref-bar .ref-file-label:hover { border-color: var(--accent); color: var(--text); }
  .ref-bar .ref-file-label input { display: none; }
  .ref-info {
    font-size: 12px; color: var(--text-dim); display: flex; align-items: center; gap: 8px;
    flex: 1; min-width: 200px;
  }
  .ref-info .ref-name { color: var(--accent); font-weight: 600; }
  .ref-info .ref-genes { color: var(--text-dim); }
  .ref-clear {
    background: none; border: 1px solid var(--border); color: var(--text-dim);
    border-radius: 5px; padding: 3px 10px; cursor: pointer; font-size: 11px;
  }
  .ref-clear:hover { border-color: var(--danger); color: var(--danger); }
  .ref-status { font-size: 12px; color: var(--text-dim); font-style: italic; }

  .btn-sm {
    background: var(--accent); border: none; color: #fff;
    border-radius: 5px; padding: 6px 14px; cursor: pointer; font-size: 12px;
    transition: all 0.15s;
  }
  .btn-sm:hover { background: var(--accent-hover); }
  .btn-sm:disabled { opacity: 0.5; cursor: not-allowed; }

  /* Drop zone */
  .dropzone {
    border: 2px dashed var(--border); border-radius: 10px;
    padding: 32px; text-align: center; cursor: pointer;
    transition: all 0.2s; margin-bottom: 16px; position: relative;
  }
  .dropzone.dragover { border-color: var(--accent); background: rgba(91,141,239,0.06); }
  .dropzone p { color: var(--text-dim); font-size: 14px; }
  .dropzone .icon { font-size: 28px; margin-bottom: 8px; color: var(--text-dim); }
  .dropzone input[type="file"] {
    position: absolute; inset: 0; opacity: 0; cursor: pointer;
  }
  .drop-status {
    margin-top: 10px; display: flex; align-items: center; justify-content: center; gap: 12px;
  }
  .drop-status .count { font-size: 13px; color: var(--text); }
  .drop-status .clear-btn {
    background: none; border: 1px solid var(--border); color: var(--text-dim);
    border-radius: 5px; padding: 3px 10px; cursor: pointer; font-size: 11px;
  }
  .drop-status .clear-btn:hover { border-color: var(--danger); color: var(--danger); }

  .summary-row {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 10px; margin-bottom: 16px;
  }
  .card {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 8px; padding: 12px 16px; text-align: center;
  }
  .card .label { font-size: 11px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; }
  .card .value { font-size: 22px; font-weight: 700; margin-top: 2px; }

  .filter-bar {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 8px; padding: 14px 18px; margin-bottom: 16px;
    display: flex; flex-wrap: wrap; gap: 14px; align-items: flex-end;
  }
  .filter-group { display: flex; flex-direction: column; gap: 4px; }
  .filter-group label { font-size: 11px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; }
  .filter-group select, .filter-group input[type="number"] {
    background: var(--surface2); border: 1px solid var(--border);
    color: var(--text); border-radius: 5px; padding: 6px 10px;
    font-size: 13px; outline: none;
  }
  .filter-group select:focus, .filter-group input:focus { border-color: var(--accent); }
  .range-wrapper { display: flex; align-items: center; gap: 6px; }
  .checkbox-label {
    display: flex; align-items: center; gap: 6px; font-size: 13px;
    cursor: pointer; padding: 6px 0;
  }
  .checkbox-label input { accent-color: var(--accent); }
  .toggle-group { display: flex; border: 1px solid var(--border); border-radius: 5px; overflow: hidden; }
  .toggle-group button {
    background: var(--surface2); border: none; color: var(--text-dim);
    padding: 5px 12px; font-size: 12px; cursor: pointer; border-right: 1px solid var(--border);
    transition: all 0.15s;
  }
  .toggle-group button:last-child { border-right: none; }
  .toggle-group button:hover { color: var(--text); }
  .toggle-group button.active { background: var(--accent); color: #fff; }
  .filter-reset {
    background: none; border: 1px solid var(--border); color: var(--text-dim);
    border-radius: 5px; padding: 6px 12px; cursor: pointer; font-size: 12px;
    align-self: flex-end;
  }
  .filter-reset:hover { border-color: var(--accent); color: var(--text); }

  .tab-bar {
    display: flex; gap: 0; margin-bottom: 16px;
  }
  .tab-bar .toggle-group button { padding: 7px 20px; font-size: 13px; font-weight: 600; }

  .analysis-section {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 8px; padding: 16px; margin-bottom: 16px;
  }
  .analysis-section h3 { font-size: 15px; font-weight: 600; margin-bottom: 10px; }
  .analysis-controls {
    display: flex; align-items: center; gap: 12px; margin-bottom: 12px;
  }
  .analysis-controls label { font-size: 11px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; }
  .analysis-guide {
    font-size: 12px; color: var(--text-dim); line-height: 1.6;
    background: var(--surface2); border: 1px solid var(--border); border-radius: 6px;
    padding: 10px 14px; margin-bottom: 12px;
  }
  .analysis-guide summary {
    cursor: pointer; font-size: 12px; color: var(--text); font-weight: 600;
    user-select: none; -webkit-user-select: none;
  }
  .analysis-guide summary:hover { color: var(--accent); }
  .analysis-guide dl { margin: 8px 0 0 0; }
  .analysis-guide dt { color: var(--text); font-weight: 600; margin-top: 6px; }
  .analysis-guide dd { margin: 2px 0 0 16px; }

  .plot-container {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 8px; padding: 8px; margin-bottom: 16px;
    min-height: 400px;
  }
  #genome-plot { width: 100%; height: 420px; }

  .table-container {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 8px; overflow: hidden; margin-bottom: 16px;
  }
  .table-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 10px 16px; border-bottom: 1px solid var(--border);
  }
  .table-header h3 { font-size: 14px; font-weight: 600; }
  .table-header-left { display: flex; align-items: center; gap: 12px; }
  .table-count { font-size: 12px; color: var(--text-dim); }
  .back-btn {
    background: var(--accent); border: none; color: #fff;
    border-radius: 5px; padding: 4px 12px; cursor: pointer; font-size: 12px;
    display: none;
  }
  .back-btn:hover { background: var(--accent-hover); }
  #variant-table { font-size: 13px; }

  .tabulator { background-color: var(--surface) !important; border: none !important; }
  .tabulator .tabulator-header { background-color: var(--surface2) !important; border-bottom: 1px solid var(--border) !important; }
  .tabulator .tabulator-header .tabulator-col { background-color: var(--surface2) !important; border-right: 1px solid var(--border) !important; }
  .tabulator .tabulator-header .tabulator-col .tabulator-col-content { padding: 6px 8px !important; }
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title { font-size: 11px; text-transform: uppercase; letter-spacing: 0.3px; }
  .tabulator .tabulator-header .tabulator-header-filter input { background: var(--bg) !important; border: 1px solid var(--border) !important; color: var(--text) !important; border-radius: 3px !important; padding: 3px 6px !important; font-size: 11px !important; }
  .tabulator .tabulator-tableHolder .tabulator-table .tabulator-row { border-bottom: 1px solid var(--border) !important; }
  .tabulator .tabulator-row.tabulator-row-even { background-color: var(--surface) !important; }
  .tabulator .tabulator-row.tabulator-row-odd { background-color: rgba(36,39,54,0.5) !important; }
  .tabulator .tabulator-row:hover { background-color: rgba(91,141,239,0.08) !important; }
  .tabulator .tabulator-cell { border-right: 1px solid var(--border) !important; padding: 5px 8px !important; }
  .tabulator .tabulator-footer { background-color: var(--surface2) !important; border-top: 1px solid var(--border) !important; }
  .tabulator .tabulator-footer .tabulator-page { background: var(--surface) !important; border: 1px solid var(--border) !important; color: var(--text) !important; border-radius: 3px !important; margin: 0 2px !important; }
  .tabulator .tabulator-footer .tabulator-page.active { background: var(--accent) !important; border-color: var(--accent) !important; color: #fff !important; }

  .export-bar { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; }
  .btn {
    background: var(--surface2); border: 1px solid var(--border);
    color: var(--text); border-radius: 6px; padding: 7px 16px;
    cursor: pointer; font-size: 12px; transition: all 0.15s;
    display: inline-flex; align-items: center; gap: 6px;
  }
  .btn:hover { border-color: var(--accent); color: var(--accent); }

  .modal-overlay {
    display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.65);
    z-index: 1000; align-items: center; justify-content: center;
  }
  .modal-overlay.active { display: flex; }
  .modal {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 10px; padding: 24px; max-width: 700px; width: 92%;
    max-height: 85vh; overflow-y: auto;
  }
  .modal-title {
    font-size: 16px; font-weight: 600; margin-bottom: 16px;
    display: flex; justify-content: space-between; align-items: center;
  }
  .modal-close { background: none; border: none; color: var(--text-dim); font-size: 22px; cursor: pointer; line-height: 1; }
  .modal-close:hover { color: var(--text); }
  .modal-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .modal-field { padding: 8px 0; }
  .modal-field .mf-label { font-size: 11px; color: var(--text-dim); text-transform: uppercase; }
  .modal-field .mf-value { font-size: 14px; font-weight: 500; word-break: break-all; }
  .modal-section-title {
    font-size: 13px; font-weight: 600; color: var(--accent);
    margin-top: 16px; margin-bottom: 8px; padding-top: 12px;
    border-top: 1px solid var(--border);
  }
  .sample-list { width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 6px; }
  .sample-list th { text-align: left; padding: 5px 8px; font-size: 10px; text-transform: uppercase; color: var(--text-dim); border-bottom: 1px solid var(--border); }
  .sample-list td { padding: 4px 8px; border-bottom: 1px solid rgba(255,255,255,0.04); }
  .sample-list tr:hover td { background: rgba(91,141,239,0.06); }

  .type-badge { display: inline-block; padding: 1px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; color: #fff; }
  .type-syn { background: var(--syn); }
  .type-nonsyn { background: var(--nonsyn); }
  .type-intergenic { background: var(--intergenic); }
  .type-unknown { background: var(--unknown); }
  .flipped-badge { display: inline-block; padding: 1px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; background: var(--danger); color: #fff; }
  .pass-badge { display: inline-block; padding: 1px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; }
  .pass-yes { background: var(--success); color: #fff; }
  .pass-no { background: var(--danger); color: #fff; }

  @media (max-width: 900px) {
    .filter-bar { flex-direction: column; }
    .summary-row { grid-template-columns: repeat(3, 1fr); }
    .modal-grid { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<div class="container">

  <div class="header">
    <div>
      <h1>Variscient</h1>
      <div class="subtitle">Interactive VCF browser for within-host variant exploration. Load VCFs and reference will be autodetected, or upload a GenBank file.</div>
    </div>
  </div>
  <button class="cb-toggle" id="cb-toggle" title="Toggle colorblind-friendly palette">&#128065; Colorblind Mode</button>

  <!-- Reference bar -->
  <div class="ref-bar" id="ref-bar">
    <div class="ref-group">
      <label>NCBI Accession</label>
      <div style="display:flex; gap:6px;">
        <input type="text" id="ref-accession" placeholder="e.g. NC_045512.2">
        <button class="btn-sm" id="ref-fetch-btn">Fetch</button>
      </div>
    </div>
    <div class="ref-group">
      <label>Or upload GenBank</label>
      <label class="ref-file-label">
        Browse .gb file
        <input type="file" id="ref-file-input" accept=".gb,.gbk,.genbank,.gbff">
      </label>
    </div>
    <div class="ref-info" id="ref-info">
      <span class="ref-status" id="ref-status">No reference loaded &mdash; gene positions will be unknown</span>
    </div>
  </div>

  <!-- Drop zone -->
  <div class="dropzone" id="dropzone">
    <div class="icon">&#128451;</div>
    <p>Drag &amp; drop VCF files here, or click to browse</p>
    <p style="font-size:12px; margin-top:4px; color:var(--text-dim);">Supports original, annotated, and cleaned VCF formats</p>
    <input type="file" id="file-input" multiple accept=".vcf,.vcf.gz">
    <div class="drop-status" id="drop-status" style="display:none;">
      <span class="count" id="file-count-label">0 files loaded</span>
      <button class="clear-btn" id="clear-all-btn">Clear All</button>
    </div>
  </div>

  <!-- Summary cards -->
  <div class="summary-row">
    <div class="card"><div class="label">Unique Variants</div><div class="value" id="sum-total">0</div></div>
    <div class="card"><div class="label">Synonymous</div><div class="value" id="sum-syn" style="color:var(--syn)">0</div></div>
    <div class="card"><div class="label">Nonsynonymous</div><div class="value" id="sum-nonsyn" style="color:var(--nonsyn)">0</div></div>
    <div class="card"><div class="label">Intergenic</div><div class="value" id="sum-intergenic" style="color:var(--intergenic)">0</div></div>
    <div class="card"><div class="label">Mean AF</div><div class="value" id="sum-af">-</div></div>
    <div class="card"><div class="label">Samples Loaded</div><div class="value" id="sum-files">0</div></div>
  </div>

  <!-- Filter bar -->
  <div class="filter-bar">
    <div class="filter-group">
      <label>Allele Frequency Range</label>
      <div class="range-wrapper">
        <input type="number" id="af-min" min="0" max="1" step="0.01" value="0" style="width:70px;">
        <span>-</span>
        <input type="number" id="af-max" min="0" max="1" step="0.01" value="1" style="width:70px;">
      </div>
    </div>
    <div class="filter-group">
      <label>Min Depth</label>
      <input type="number" id="dp-min" value="0" min="0" step="10" style="width:80px;">
    </div>
    <div class="filter-group">
      <label>Gene</label>
      <select id="filter-gene"><option value="">All</option></select>
    </div>
    <div class="filter-group">
      <label>Variant Type</label>
      <select id="filter-type">
        <option value="">All</option>
        <option value="syn">Synonymous</option>
        <option value="nonsyn">Nonsynonymous</option>
        <option value="intergenic">Intergenic</option>
        <option value="unknown">Unknown</option>
      </select>
    </div>
    <div class="filter-group">
      <label>&nbsp;</label>
      <label class="checkbox-label"><input type="checkbox" id="filter-isnv"> iSNV only (AF&lt;0.5)</label>
    </div>
    <div class="filter-group">
      <label>Fixed Variants (AF&ge;0.5)</label>
      <div class="toggle-group" id="fixed-toggle">
        <button class="active" data-value="keep">Keep</button>
        <button data-value="flip">Flip</button>
        <button data-value="mask">Mask</button>
      </div>
    </div>
    <div class="filter-group">
      <label>Min Sample Count</label>
      <input type="number" id="count-min" value="0" min="0" step="1" style="width:80px;">
    </div>
    <button class="filter-reset" id="filter-reset">Reset Filters</button>
  </div>

  <!-- Tab bar -->
  <div class="tab-bar">
    <div class="toggle-group" id="main-tab-toggle">
      <button class="active" data-tab="browser">Browser</button>
      <button data-tab="analyses">Analyses</button>
    </div>
  </div>

  <!-- Browser tab content -->
  <div id="tab-browser">

  <div class="plot-container">
    <div class="table-header" style="padding: 8px 16px; border-bottom: 1px solid var(--border);">
      <div class="table-header-left">
        <h3>Genome Browser</h3>
      </div>
      <div style="display:flex; align-items:center; gap:8px;">
        <label style="font-size:11px; color:var(--text-dim);">Y-axis</label>
        <div class="toggle-group" id="plot-mode-toggle">
          <button class="active" data-value="count">Sample Count</button>
          <button data-value="af">Allele Frequency</button>
        </div>
      </div>
    </div>
    <div id="genome-plot"></div>
  </div>

  <div class="export-bar">
    <button class="btn" id="export-csv">&#x2913; Export CSV</button>
    <button class="btn" id="export-tsv">&#x2913; Export TSV</button>
    <button class="btn" id="export-png">&#x1F4F7; Plot PNG</button>
    <button class="btn" id="export-svg">&#x1F4F7; Plot SVG</button>
  </div>

  <!-- Frequency histogram -->
  <div class="plot-container">
    <div class="table-header" style="padding: 10px 16px; border-bottom: 1px solid var(--border);">
      <div class="table-header-left">
        <h3>Most Frequent Variants</h3>
      </div>
      <div style="display:flex; align-items:center; gap:8px;">
        <label style="font-size:11px; color:var(--text-dim);">Show top</label>
        <select id="hist-top-n" style="background:var(--surface2); border:1px solid var(--border); color:var(--text); border-radius:5px; padding:4px 8px; font-size:12px;">
          <option value="20" selected>20</option>
          <option value="30">30</option>
          <option value="50">50</option>
          <option value="100">100</option>
        </select>
      </div>
    </div>
    <div id="freq-histogram" style="width:100%; min-height:500px;"></div>
  </div>

  <div class="table-container">
    <div class="table-header">
      <div class="table-header-left">
        <h3 id="table-title">Variant Table</h3>
        <button class="back-btn" id="back-btn">&larr; Back to all variants</button>
      </div>
      <span class="table-count" id="table-count">0 variants</span>
    </div>
    <div id="variant-table"></div>
  </div>

  </div><!-- end #tab-browser -->

  <!-- Analyses tab content -->
  <div id="tab-analyses" style="display:none;">

    <!-- Variants Per Sample -->
    <div class="analysis-section">
      <h3>Variants Per Sample</h3>
      <div class="analysis-controls">
        <label>Type</label>
        <div class="toggle-group" id="vps-type-toggle">
          <button class="active" data-value="all">All</button>
          <button data-value="syn">Syn</button>
          <button data-value="nonsyn">Nonsyn</button>
          <button data-value="intergenic">Intergenic</button>
        </div>
      </div>
      <div id="vps-plot" style="width:100%; height:420px;"></div>
    </div>

    <!-- Site Frequency Spectrum -->
    <div class="analysis-section">
      <h3>Site Frequency Spectrum</h3>
      <details class="analysis-guide">
        <summary>How to interpret this plot</summary>
        <p style="margin-top:6px;">The SFS shows the distribution of allele frequencies across all per-sample variants. The dashed yellow line shows the neutral expectation (1/f), where most mutations are rare. Compare the observed bars to this line:</p>
        <dl>
          <dt>Bars follow the 1/f line</dt>
          <dd>Consistent with neutral evolution &mdash; most variants are rare, as expected under drift alone.</dd>
          <dt>Excess of low-frequency variants (left side above the line)</dt>
          <dd>Suggests purifying selection removing deleterious variants before they rise in frequency, or recent population expansion generating new rare mutations.</dd>
          <dt>Excess of intermediate-frequency variants (middle above the line)</dt>
          <dd>May indicate balancing selection, population structure, or mixed infections with distinct lineages.</dd>
          <dt>Excess of high-frequency variants (right side above the line)</dt>
          <dd>Can indicate positive selection driving variants toward fixation, or a population bottleneck reducing diversity.</dd>
          <dt>Compare Syn vs. Nonsyn</dt>
          <dd>Synonymous variants approximate the neutral expectation. If nonsynonymous variants show a different shape (e.g., shifted left), this suggests purifying selection on protein-coding changes.</dd>
        </dl>
      </details>
      <div class="analysis-controls">
        <label>Type</label>
        <div class="toggle-group" id="sfs-type-toggle">
          <button class="active" data-value="all">All</button>
          <button data-value="syn">Syn</button>
          <button data-value="nonsyn">Nonsyn</button>
          <button data-value="intergenic">Intergenic</button>
        </div>
      </div>
      <div id="sfs-plot" style="width:100%; height:420px;"></div>
      <div id="sfs-summary" style="font-size:12px; color:var(--text-dim); padding:8px 4px 0; line-height:1.5;"></div>
    </div>

    <!-- Mutational Spectrum -->
    <div class="analysis-section">
      <h3>Mutational Spectrum</h3>
      <details class="analysis-guide">
        <summary>How to interpret this plot</summary>
        <p style="margin-top:6px;">The mutational spectrum shows the count of each single-nucleotide substitution type. The pattern reveals the dominant mutational processes acting on the pathogen:</p>
        <dl>
          <dt>C&gt;T and G&gt;A dominant (transitions)</dt>
          <dd>Common in RNA viruses. Often driven by ADAR (adenosine deaminase) editing on the negative-sense strand (appears as A&gt;G / T&gt;C on the coding strand) or spontaneous cytosine deamination.</dd>
          <dt>A&gt;G / T&gt;C enrichment</dt>
          <dd>Signature of ADAR editing, particularly in negative-sense RNA viruses like measles and paramyxoviruses.</dd>
          <dt>C&gt;A / G&gt;T enrichment</dt>
          <dd>May indicate oxidative damage (8-oxoguanine), which is sometimes a sequencing artifact.</dd>
          <dt>Transition/transversion ratio (Ti/Tv)</dt>
          <dd>High Ti/Tv (&gt;2) is typical for biological mutations. Low Ti/Tv (~0.5) may suggest sequencing errors or artifacts.</dd>
          <dt>Compare Syn vs. Nonsyn</dt>
          <dd>If the spectrum shape changes between synonymous and nonsynonymous variants, selection may be filtering certain mutation types at the protein level.</dd>
        </dl>
      </details>
      <div class="analysis-controls">
        <label>Type</label>
        <div class="toggle-group" id="mut-type-toggle">
          <button class="active" data-value="all">All</button>
          <button data-value="syn">Syn</button>
          <button data-value="nonsyn">Nonsyn</button>
          <button data-value="intergenic">Intergenic</button>
        </div>
      </div>
      <div id="mut-spectrum-plot" style="width:100%; height:420px;"></div>
    </div>

    <!-- dN/dS Analysis -->
    <div class="analysis-section">
      <h3>dN/dS</h3>
      <details class="analysis-guide">
        <summary>How to interpret this plot</summary>
        <p style="margin-top:6px;">dN/dS (also called &omega;) is the ratio of nonsynonymous to synonymous substitution rates. It measures selective pressure on protein-coding genes:</p>
        <dl>
          <dt>dN/dS &asymp; 1</dt>
          <dd>Neutral evolution &mdash; nonsynonymous and synonymous changes accumulate at similar rates, suggesting no strong selection on the protein.</dd>
          <dt>dN/dS &lt; 1 (purifying selection)</dt>
          <dd>Nonsynonymous changes are removed by selection, preserving protein function. Most genes fall here.</dd>
          <dt>dN/dS &gt; 1 (positive selection)</dt>
          <dd>Nonsynonymous changes are favoured, suggesting adaptive evolution &mdash; e.g., immune evasion or host adaptation.</dd>
          <dt>Error bars</dt>
          <dd>95% confidence intervals from per-sample variation. Wide bars indicate high heterogeneity across samples.</dd>
        </dl>
      </details>
      <div class="analysis-controls">
        <label>Mode</label>
        <div class="toggle-group" id="dnds-mode-toggle">
          <button class="active" data-value="pergene">Per Gene</button>
          <button data-value="rolling">Rolling Window</button>
        </div>
        <label id="dnds-window-label" style="display:none;">Window (nt)</label>
        <div class="toggle-group" id="dnds-window-toggle" style="display:none;">
          <button data-value="10">10</button>
          <button data-value="25">25</button>
          <button data-value="50">50</button>
          <button class="active" data-value="100">100</button>
          <button data-value="200">200</button>
          <button data-value="500">500</button>
        </div>
      </div>
      <div id="dnds-plot" style="width:100%; height:420px;"></div>
    </div>

  </div><!-- end #tab-analyses -->

</div>

<div class="modal-overlay" id="modal-overlay">
  <div class="modal">
    <div class="modal-title">
      <span>Variant Details</span>
      <button class="modal-close" id="modal-close">&times;</button>
    </div>
    <div id="modal-body"></div>
  </div>
</div>

<script>
// ============================================================
// CONSTANTS
// ============================================================
const GENE_PALETTE = [
  '#4a90a4','#6a5acd','#2e8b57','#b8860b','#cd5c5c',
  '#4682b4','#8b668b','#d2691e','#5f9ea0','#bc8f8f',
  '#6b8e23','#9370db','#20b2aa','#db7093','#778899',
];
const TYPE_COLORS = {
  syn: '#527F91', nonsyn: '#a0392d', intergenic: '#888899',
  unknown: '#888899',
};

// ============================================================
// STATE
// ============================================================
const state = {
  // Reference
  genes: [],           // [{ name, start, end, color, product }]
  genomeLength: 0,     // from GenBank LOCUS line
  refName: '',         // organism / definition
  refAccession: '',
  refSequence: '',     // nucleotide sequence from ORIGIN

  // VCF data
  fileNames: [],
  variants: [],
  filtered: [],
  aggregated: [],
  table: null,
  tableMode: 'aggregated',
  selectedVariantKey: null,
  hasCleaned: false,
  fixedMode: 'keep', // 'keep', 'flip', 'mask'
  plotMode: 'count', // 'count' or 'af'
};

// Analysis tab state (declared early for Safari TDZ compatibility)
var activeTab = 'browser';
var analysesNeedUpdate = false;
var sfsTypeFilter = 'all';
var sfsInitialized = false;
var vpsTypeFilter = 'all';
var vpsInitialized = false;
var mutTypeFilter = 'all';
var mutInitialized = false;
var dndsMode = 'pergene';
var dndsWindowSize = 100;
var dndsInitialized = false;
var siteCache = {};

var COMPLEMENT = { A: 'T', T: 'A', C: 'G', G: 'C' };
var MUT_CATEGORIES = [
  'A>C', 'A>G', 'A>T',
  'C>A', 'C>G', 'C>T',
  'G>A', 'G>C', 'G>T',
  'T>A', 'T>C', 'T>G',
];
var MUT_GROUP_COLORS = { A: '#5b8def', C: '#E62223', G: '#97D54C', T: '#CBCACB' };

// ============================================================
// COLORBLIND-SAFE PALETTES (Okabe-Ito / Wong)
// ============================================================
var DEFAULT_TYPE_COLORS = { syn: '#527F91', nonsyn: '#a0392d', intergenic: '#888899', unknown: '#888899' };
var CB_TYPE_COLORS = { syn: '#0072B2', nonsyn: '#D55E00', intergenic: '#F0E442', unknown: '#999999' };

var DEFAULT_MUT_GROUP_COLORS = { A: '#5b8def', C: '#E62223', G: '#97D54C', T: '#CBCACB' };
var CB_MUT_GROUP_COLORS = { A: '#0072B2', C: '#D55E00', G: '#009E73', T: '#CC79A7' };

var DEFAULT_GENE_PALETTE = GENE_PALETTE.slice();
var CB_GENE_PALETTE = [
  '#0072B2','#D55E00','#009E73','#F0E442','#CC79A7',
  '#56B4E9','#E69F00','#000000','#648FFF','#DC267F',
  '#785EF0','#FE6100','#FFB000','#22D1EE','#8B4513',
];

var DEFAULT_TYPE_BAR_COLORS = { all: '#5b8def', syn: '#527F91', nonsyn: '#a0392d', intergenic: '#888899' };
var CB_TYPE_BAR_COLORS = { all: '#56B4E9', syn: '#0072B2', nonsyn: '#D55E00', intergenic: '#F0E442' };

var colorblindMode = false;

function applyColorblindPalette(enabled) {
  colorblindMode = enabled;
  document.documentElement.setAttribute('data-theme', enabled ? 'colorblind' : '');
  // Swap JS color objects
  TYPE_COLORS.syn = enabled ? CB_TYPE_COLORS.syn : DEFAULT_TYPE_COLORS.syn;
  TYPE_COLORS.nonsyn = enabled ? CB_TYPE_COLORS.nonsyn : DEFAULT_TYPE_COLORS.nonsyn;
  TYPE_COLORS.intergenic = enabled ? CB_TYPE_COLORS.intergenic : DEFAULT_TYPE_COLORS.intergenic;
  TYPE_COLORS.unknown = enabled ? CB_TYPE_COLORS.unknown : DEFAULT_TYPE_COLORS.unknown;
  MUT_GROUP_COLORS.A = enabled ? CB_MUT_GROUP_COLORS.A : DEFAULT_MUT_GROUP_COLORS.A;
  MUT_GROUP_COLORS.C = enabled ? CB_MUT_GROUP_COLORS.C : DEFAULT_MUT_GROUP_COLORS.C;
  MUT_GROUP_COLORS.G = enabled ? CB_MUT_GROUP_COLORS.G : DEFAULT_MUT_GROUP_COLORS.G;
  MUT_GROUP_COLORS.T = enabled ? CB_MUT_GROUP_COLORS.T : DEFAULT_MUT_GROUP_COLORS.T;
  var srcPalette = enabled ? CB_GENE_PALETTE : DEFAULT_GENE_PALETTE;
  for (var i = 0; i < GENE_PALETTE.length; i++) {
    GENE_PALETTE[i] = srcPalette[i % srcPalette.length];
  }
  // Update gene colors already stored in state
  if (state.genes && state.genes.length) {
    for (var j = 0; j < state.genes.length; j++) {
      state.genes[j].color = GENE_PALETTE[j % GENE_PALETTE.length];
    }
  }
  // Toggle button style
  var btn = document.getElementById('cb-toggle');
  if (btn) { enabled ? btn.classList.add('active') : btn.classList.remove('active'); }
}

function toggleColorblindMode() {
  var enabled = !colorblindMode;
  applyColorblindPalette(enabled);
  try { localStorage.setItem('variscient-colorblind', enabled ? '1' : ''); } catch(e) {}
  // Re-render all visible plots
  updatePlot();
  updateHistogram();
  if (activeTab === 'analyses') {
    updateVPS();
    updateSFS();
    updateMutSpectrum();
    updateDnDs();
  } else {
    analysesNeedUpdate = true;
  }
}

// ============================================================
// SAMPLE NAME — everything before first '.'
// ============================================================
function sampleName(fileName) {
  const dot = fileName.indexOf('.');
  return dot > 0 ? fileName.substring(0, dot) : fileName;
}

// ============================================================
// GENBANK PARSER
// ============================================================
function parseGenBank(text) {
  const lines = text.split('\n');
  let genomeLength = 0;
  let organism = '';
  let definition = '';
  let accession = '';
  const cdsFeatures = [];
  let sequence = '';

  // Parse LOCUS line for length
  const locusMatch = lines[0] && lines[0].match(/LOCUS\s+\S+\s+(\d+)\s+bp/);
  if (locusMatch) genomeLength = parseInt(locusMatch[1], 10);

  // Parse header fields
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.startsWith('DEFINITION')) {
      definition = line.substring(12).trim().replace(/\.$/, '');
    } else if (line.startsWith('ACCESSION')) {
      accession = line.substring(12).trim().split(/\s+/)[0];
    } else if (line.startsWith('  ORGANISM')) {
      organism = line.substring(12).trim();
    } else if (line.startsWith('FEATURES')) {
      break;
    }
  }

  // Parse FEATURES section — extract CDS entries
  let inFeatures = false;
  let currentFeature = null;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.startsWith('FEATURES')) { inFeatures = true; continue; }
    if (line.startsWith('ORIGIN') || line.startsWith('//')) {
      if (currentFeature && currentFeature.type === 'CDS') cdsFeatures.push(currentFeature);
      break;
    }
    if (!inFeatures) continue;

    // New feature line: type starts at col 5, location at col 21
    const featureMatch = line.match(/^     (\S+)\s+(.+)$/);
    if (featureMatch) {
      if (currentFeature && currentFeature.type === 'CDS') cdsFeatures.push(currentFeature);
      currentFeature = {
        type: featureMatch[1],
        locationStr: featureMatch[2].trim(),
        qualifiers: {},
      };
      continue;
    }

    // Qualifier or continuation
    if (currentFeature && line.startsWith('                     /')) {
      const qualMatch = line.trim().match(/^\/(\w+)="?([^"]*)"?$/);
      if (qualMatch) {
        currentFeature.qualifiers[qualMatch[1]] = qualMatch[2];
      }
    }
  }

  // Parse ORIGIN section for sequence
  let inOrigin = false;
  const seqParts = [];
  for (const line of lines) {
    if (line.startsWith('ORIGIN')) { inOrigin = true; continue; }
    if (line.startsWith('//')) break;
    if (inOrigin) {
      seqParts.push(line.replace(/[\s\d]/g, ''));
    }
  }
  sequence = seqParts.join('').toUpperCase();

  // Convert CDS features to genes array
  const genes = [];
  const seenGenes = new Set();
  for (const feat of cdsFeatures) {
    const geneName = feat.qualifiers.gene || feat.qualifiers.product || 'unknown';
    // Skip duplicate gene names (e.g. V protein, C protein share gene with P)
    // Keep the first (usually the main CDS)
    if (seenGenes.has(geneName)) continue;
    seenGenes.add(geneName);

    const coords = parseGBLocation(feat.locationStr);
    if (!coords) continue;

    genes.push({
      name: geneName,
      start: coords.start,
      end: coords.end,
      product: feat.qualifiers.product || geneName,
      color: GENE_PALETTE[genes.length % GENE_PALETTE.length],
    });
  }

  // Sort genes by start position
  genes.sort((a, b) => a.start - b.start);

  return {
    genes,
    genomeLength: genomeLength || (sequence.length) || 0,
    organism,
    definition,
    accession,
    sequence,
  };
}

function parseGBLocation(locStr) {
  // Handle complement(...), join(...), simple start..end
  // We extract the overall min start and max end
  const numbers = [];
  const numMatches = locStr.matchAll(/(\d+)/g);
  for (const m of numMatches) numbers.push(parseInt(m[1], 10));
  if (numbers.length < 2) return null;
  return { start: Math.min(...numbers), end: Math.max(...numbers) };
}

// ============================================================
// CODON TABLE + TRANSLATION
// ============================================================
const CODON_TABLE = {
  'TTT':'F','TTC':'F','TTA':'L','TTG':'L','CTT':'L','CTC':'L','CTA':'L','CTG':'L',
  'ATT':'I','ATC':'I','ATA':'I','ATG':'M','GTT':'V','GTC':'V','GTA':'V','GTG':'V',
  'TCT':'S','TCC':'S','TCA':'S','TCG':'S','CCT':'P','CCC':'P','CCA':'P','CCG':'P',
  'ACT':'T','ACC':'T','ACA':'T','ACG':'T','GCT':'A','GCC':'A','GCA':'A','GCG':'A',
  'TAT':'Y','TAC':'Y','TAA':'*','TAG':'*','CAT':'H','CAC':'H','CAA':'Q','CAG':'Q',
  'AAT':'N','AAC':'N','AAA':'K','AAG':'K','GAT':'D','GAC':'D','GAA':'E','GAG':'E',
  'TGT':'C','TGC':'C','TGA':'*','TGG':'W','CGT':'R','CGC':'R','CGA':'R','CGG':'R',
  'AGT':'S','AGC':'S','AGA':'R','AGG':'R','GGT':'G','GGC':'G','GGA':'G','GGG':'G',
};

function translateCodon(codon) {
  return CODON_TABLE[codon.toUpperCase()] || '?';
}

// ============================================================
// ANNOTATE VARIANT using reference sequence + gene coords
// ============================================================
function annotateVariant(pos, ref, alt, genes, sequence) {
  // pos is 1-based
  if (!sequence || sequence.length === 0) return { gene: classifyGeneByPos(pos), aaChange: null, type: 'unknown' };

  const gene = findGeneForPos(pos, genes);
  if (!gene) return { gene: 'intergenic', aaChange: 'intergenic', type: 'intergenic' };

  // Only annotate single-base substitutions
  if (ref.length !== 1 || alt.length !== 1) {
    return { gene: gene.name, aaChange: null, type: 'unknown' };
  }

  // Calculate codon position within the CDS
  const posInCDS = pos - gene.start; // 0-based offset from CDS start
  const codonIndex = Math.floor(posInCDS / 3);
  const posInCodon = posInCDS % 3;
  const codonStart = gene.start + (codonIndex * 3); // 1-based genome position

  // Extract reference codon (convert to 0-based for sequence indexing)
  if (codonStart - 1 < 0 || codonStart + 2 > sequence.length) {
    return { gene: gene.name, aaChange: null, type: 'unknown' };
  }
  const refCodon = sequence.substring(codonStart - 1, codonStart + 2);
  const altCodon = refCodon.substring(0, posInCodon) + alt + refCodon.substring(posInCodon + 1);

  const refAA = translateCodon(refCodon);
  const altAA = translateCodon(altCodon);
  const aaPos = codonIndex + 1;

  const aaChange = `${refAA}${aaPos}${altAA}`;

  if (refAA === altAA) {
    return { gene: gene.name, aaChange: aaChange + '(syn)', type: 'syn' };
  } else {
    return { gene: gene.name, aaChange, type: 'nonsyn' };
  }
}

function findGeneForPos(pos, genes) {
  for (const g of genes) {
    if (pos >= g.start && pos <= g.end) return g;
  }
  return null;
}

function classifyGeneByPos(pos) {
  for (const g of state.genes) {
    if (pos >= g.start && pos <= g.end) return g.name;
  }
  return 'intergenic';
}

// ============================================================
// dN/dS: COUNT SYNONYMOUS / NONSYNONYMOUS SITES (Nei-Gojobori)
// ============================================================
var BASES = ['A', 'C', 'G', 'T'];

function countSynNonsynSites(gene) {
  var key = gene.name + ':' + gene.start + '-' + gene.end;
  if (siteCache[key]) return siteCache[key];

  var seq = state.refSequence;
  if (!seq) return null;

  var synSites = 0, nonsynSites = 0;
  var cdsLen = gene.end - gene.start + 1;
  var nCodons = Math.floor(cdsLen / 3);

  for (var ci = 0; ci < nCodons; ci++) {
    var codonStart = gene.start + ci * 3; // 1-based
    if (codonStart - 1 < 0 || codonStart + 2 > seq.length) continue;
    var codon = seq.substring(codonStart - 1, codonStart + 2).toUpperCase();
    var refAA = CODON_TABLE[codon];
    if (!refAA) continue;

    // For each position in the codon, count syn/nonsyn single-nt changes
    for (var p = 0; p < 3; p++) {
      var synChanges = 0, nonsynChanges = 0;
      var origBase = codon[p];
      for (var bi = 0; bi < 4; bi++) {
        var newBase = BASES[bi];
        if (newBase === origBase) continue;
        var mutCodon = codon.substring(0, p) + newBase + codon.substring(p + 1);
        var mutAA = CODON_TABLE[mutCodon];
        if (!mutAA) continue;
        if (mutAA === refAA) synChanges++;
        else nonsynChanges++;
      }
      synSites += synChanges / 3;
      nonsynSites += nonsynChanges / 3;
    }
  }

  var result = { synSites: synSites, nonsynSites: nonsynSites };
  siteCache[key] = result;
  return result;
}

// ============================================================
// REFERENCE LOADING
// ============================================================
function loadReference(gbText) {
  const ref = parseGenBank(gbText);
  state.genes = ref.genes;
  state.genomeLength = ref.genomeLength;
  state.refName = ref.organism || ref.definition;
  state.refAccession = ref.accession;
  state.refSequence = ref.sequence;
  siteCache = {};
  dndsInitialized = false;

  updateRefUI();
  updateGeneFilter();

  // Re-annotate any already-loaded variants that lack annotation
  if (state.variants.length > 0) {
    reannotateVariants();
    applyFilters();
  }

  plotInitialized = false;
  updatePlot();
}

function reannotateVariants() {
  for (const v of state.variants) {
    if (v._hasVCFAnnotation) continue; // keep original VCF annotation
    const ann = annotateVariant(v.pos, v.ref, v.alt, state.genes, state.refSequence);
    v.gene = ann.gene;
    v.aaChange = ann.aaChange;
    v.type = ann.type;
  }
}

function updateRefUI() {
  const el = document.getElementById('ref-status');
  if (state.genes.length > 0) {
    const geneNames = state.genes.map(g => g.name).join(', ');
    el.innerHTML = `<span class="ref-name">${state.refName || state.refAccession}</span>` +
      ` &mdash; ${state.genomeLength.toLocaleString()} bp, ${state.genes.length} genes: ` +
      `<span class="ref-genes">${geneNames}</span>` +
      ` <button class="ref-clear" id="ref-clear-btn">Clear</button>`;
    document.getElementById('ref-clear-btn').addEventListener('click', clearReference);
  } else {
    el.innerHTML = 'No reference loaded &mdash; gene positions will be unknown';
  }
}

function clearReference() {
  state.genes = [];
  state.genomeLength = 0;
  state.refName = '';
  state.refAccession = '';
  state.refSequence = '';
  siteCache = {};
  dndsInitialized = false;
  updateRefUI();
  updateGeneFilter();
  // Re-classify variants without reference
  for (const v of state.variants) {
    if (v._hasVCFAnnotation) continue;
    v.gene = 'intergenic';
    v.aaChange = null;
    v.type = 'unknown';
  }
  plotInitialized = false;
  applyFilters();
}

function updateGeneFilter() {
  const sel = document.getElementById('filter-gene');
  const current = sel.value;
  sel.innerHTML = '<option value="">All</option>';
  for (const g of state.genes) {
    sel.innerHTML += `<option value="${g.name}">${g.name}</option>`;
  }
  sel.innerHTML += '<option value="intergenic">intergenic</option>';
  sel.value = current;
}

// Reference file input
document.getElementById('ref-file-input').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => loadReference(ev.target.result);
  reader.readAsText(file);
  e.target.value = '';
});

// NCBI fetch
document.getElementById('ref-fetch-btn').addEventListener('click', fetchNCBIReference);
document.getElementById('ref-accession').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') fetchNCBIReference();
});

async function fetchNCBIReference() {
  const acc = document.getElementById('ref-accession').value.trim();
  if (!acc) return;
  const btn = document.getElementById('ref-fetch-btn');
  const statusEl = document.getElementById('ref-status');
  btn.disabled = true;
  btn.textContent = 'Fetching...';
  statusEl.textContent = `Fetching ${acc} from NCBI...`;

  try {
    const url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nucleotide&id=${encodeURIComponent(acc)}&rettype=gb&retmode=text`;
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const text = await resp.text();
    if (!text.startsWith('LOCUS')) throw new Error('Response is not a valid GenBank record');
    loadReference(text);
  } catch (err) {
    statusEl.textContent = `Failed to fetch ${acc}: ${err.message}`;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Fetch';
  }
}

// ============================================================
// VCF PARSER
// ============================================================
function parseINFO(infoStr) {
  const info = {};
  if (!infoStr || infoStr === '.') return info;
  for (const p of infoStr.split(';')) {
    const eq = p.indexOf('=');
    if (eq === -1) info[p] = true;
    else info[p.substring(0, eq)] = p.substring(eq + 1);
  }
  return info;
}

function parseAnnotation(ann) {
  if (!ann) return { gene: null, aaChange: null, type: 'unknown' };
  const s = String(ann);
  if (s === 'intergenic') return { gene: 'intergenic', aaChange: 'intergenic', type: 'intergenic' };
  let cleaned = s;
  if (s.includes('(MNV)')) cleaned = cleaned.replace('(MNV)', '');
  const isSyn = s.includes('(syn)');
  if (isSyn) cleaned = cleaned.replace('(syn)', '');
  let type = isSyn ? 'syn' : 'nonsyn';
  const ci = cleaned.indexOf(':');
  if (ci === -1) return { gene: cleaned, aaChange: cleaned, type };
  let aaChange = cleaned.substring(ci + 1);
  if (aaChange.startsWith('p.')) aaChange = aaChange.substring(2);
  return { gene: cleaned.substring(0, ci), aaChange, type };
}

function parseVCF(text, fileName) {
  const lines = text.split('\n');
  const variants = [];
  let hasANN = false, hasCleaned = false;

  for (const line of lines) {
    if (!line.startsWith('#')) break;
    if (line.includes('ID=ANN')) hasANN = true;
    if (line.includes('ID=FLIPPED') || line.includes('ID=PVAL_CORR')) hasCleaned = true;
  }

  const sample = sampleName(fileName);

  for (const line of lines) {
    if (line.startsWith('#') || line.trim() === '') continue;
    const cols = line.split('\t');
    if (cols.length < 8) continue;

    const pos = parseInt(cols[1], 10);
    const ref = cols[3], alt = cols[4];
    const qual = parseFloat(cols[5]);
    const filter = cols[6];
    const info = parseINFO(cols[7]);

    const dp = info.DP ? parseInt(info.DP, 10) : null;
    const af = info.AF ? parseFloat(info.AF) : null;
    const sb = info.SB ? parseInt(info.SB, 10) : null;
    const dp4 = info.DP4 || null;

    let gene, aaChange, type, hasVCFAnnotation = false;
    if (hasANN && info.ANN) {
      const parsed = parseAnnotation(info.ANN);
      gene = parsed.gene; aaChange = parsed.aaChange; type = parsed.type;
      hasVCFAnnotation = true;
    } else if (state.genes.length > 0 && state.refSequence) {
      const ann = annotateVariant(pos, ref, alt, state.genes, state.refSequence);
      gene = ann.gene; aaChange = ann.aaChange; type = ann.type;
    } else {
      gene = classifyGeneByPos(pos);
      aaChange = null;
      type = 'unknown';
    }

    const flipped = info.FLIPPED === true || info.FLIPPED === 'true' || info.FLIPPED === '1';
    const pval = info.PVAL != null ? parseFloat(info.PVAL) : null;
    const pvalCorr = info.PVAL_CORR != null ? parseFloat(info.PVAL_CORR) : null;
    const passBinom = info.PASS_BINOM === true || info.PASS_BINOM === 'true' || info.PASS_BINOM === '1';

    // Detect cleaned fields from data if header detection missed them
    if (!hasCleaned && (info.PVAL_CORR != null || info.FLIPPED != null || info.PASS_BINOM != null)) {
      hasCleaned = true;
    }

    variants.push({
      file: sample, pos, ref, alt, qual, filter,
      dp, af, sb, dp4,
      gene, aaChange, type,
      flipped, pval, pvalCorr, passBinom,
      hasCleaned,
      _hasVCFAnnotation: hasVCFAnnotation,
    });
  }

  // Detect reference accession from CHROM column of first data line
  let detectedRef = null;
  for (const line of lines) {
    if (line.startsWith('#') || line.trim() === '') continue;
    const chrom = line.split('\t')[0];
    if (chrom) {
      // Try to extract accession pattern like NC_001498.1 from chrom name
      const accMatch = chrom.match(/([A-Z]{1,2}_\d+\.\d+)/);
      if (accMatch) detectedRef = accMatch[1];
      else detectedRef = chrom; // use full chrom name as fallback
    }
    break;
  }

  return { variants, hasCleaned, detectedRef };
}

// ============================================================
// AGGREGATION
// ============================================================
function variantKey(v) { return `${v.pos}_${v.ref}_${v.alt}`; }

function aggregateVariants(filtered) {
  const map = new Map();
  for (const v of filtered) {
    const key = variantKey(v);
    if (!map.has(key)) {
      map.set(key, { key, pos: v.pos, ref: v.ref, alt: v.alt,
        gene: v.gene, aaChange: v.aaChange, type: v.type, samples: [] });
    }
    const agg = map.get(key);
    agg.samples.push(v);
    if (v.aaChange && !agg.aaChange) { agg.aaChange = v.aaChange; agg.gene = v.gene; agg.type = v.type; }
    if (v.type !== 'unknown' && agg.type === 'unknown') { agg.type = v.type; agg.gene = v.gene; }
  }
  const result = [];
  for (const agg of map.values()) {
    const afs = agg.samples.filter(s => s.af != null).map(s => s.af);
    agg.count = agg.samples.length;
    agg.meanAF = afs.length ? afs.reduce((a, b) => a + b, 0) / afs.length : null;
    agg.minAF = afs.length ? Math.min(...afs) : null;
    agg.maxAF = afs.length ? Math.max(...afs) : null;
    result.push(agg);
  }
  return result;
}

// ============================================================
// FILE HANDLING
// ============================================================
function addFiles(fileList) {
  let pending = 0;
  let firstDetectedRef = null;
  for (const file of fileList) {
    if (state.fileNames.includes(file.name)) continue;
    state.fileNames.push(file.name);
    pending++;
    const reader = new FileReader();
    reader.onload = (e) => {
      const result = parseVCF(e.target.result, file.name);
      state.variants.push(...result.variants);
      if (result.hasCleaned) state.hasCleaned = true;
      if (result.detectedRef && !firstDetectedRef) firstDetectedRef = result.detectedRef;
      pending--;
      if (pending === 0) {
        // Auto-fetch reference if none loaded and we detected an accession
        if (firstDetectedRef && state.genes.length === 0 && !state._autoFetching) {
          autoFetchReference(firstDetectedRef);
        }
        applyFilters(); updateDropStatus();
      }
    };
    reader.readAsText(file);
  }
  updateDropStatus();
}

async function autoFetchReference(accession) {
  state._autoFetching = true;
  const statusEl = document.getElementById('ref-status');
  const accInput = document.getElementById('ref-accession');
  accInput.value = accession;
  statusEl.textContent = `Auto-detected reference ${accession}, fetching from NCBI...`;

  try {
    const url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nucleotide&id=${encodeURIComponent(accession)}&rettype=gb&retmode=text`;
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const text = await resp.text();
    if (!text.startsWith('LOCUS')) throw new Error('Response is not a valid GenBank record');
    loadReference(text);
  } catch (err) {
    statusEl.textContent = `Auto-fetch failed for ${accession}: ${err.message}. You can manually enter an accession or upload a GenBank file.`;
  } finally {
    state._autoFetching = false;
  }
}

function clearAllFiles() {
  state.fileNames = []; state.variants = []; state.filtered = [];
  state.aggregated = []; state.hasCleaned = false;
  state.tableMode = 'aggregated'; state.selectedVariantKey = null;
  applyFilters(); updateDropStatus();
}

function updateDropStatus() {
  const n = state.fileNames.length;
  const status = document.getElementById('drop-status');
  if (n === 0) { status.style.display = 'none'; }
  else {
    status.style.display = 'flex';
    document.getElementById('file-count-label').textContent = `${n} file${n !== 1 ? 's' : ''} loaded`;
  }
  document.getElementById('sum-files').textContent = n;
}

// Drop zone events
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('file-input');
dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('dragover'); });
dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
dropzone.addEventListener('drop', (e) => {
  e.preventDefault(); dropzone.classList.remove('dragover');
  if (e.dataTransfer.files.length) addFiles(e.dataTransfer.files);
});
fileInput.addEventListener('change', (e) => { if (e.target.files.length) addFiles(e.target.files); e.target.value = ''; });
document.getElementById('clear-all-btn').addEventListener('click', (e) => { e.stopPropagation(); clearAllFiles(); });

// ============================================================
// FILTERS
// ============================================================
const afMinEl = document.getElementById('af-min');
const afMaxEl = document.getElementById('af-max');
const dpMinEl = document.getElementById('dp-min');
const filterGene = document.getElementById('filter-gene');
const filterType = document.getElementById('filter-type');
const filterIsnv = document.getElementById('filter-isnv');
const countMinEl = document.getElementById('count-min');

function getFilters() {
  return {
    afMin: parseFloat(afMinEl.value), afMax: parseFloat(afMaxEl.value),
    dpMin: parseInt(dpMinEl.value, 10) || 0,
    gene: filterGene.value, type: filterType.value,
    isnvOnly: filterIsnv.checked,
    countMin: parseInt(countMinEl.value, 10) || 0,
    fixedMode: state.fixedMode,
  };
}

function flipAaChange(aaChange) {
  if (!aaChange || aaChange === 'intergenic') return aaChange;
  let suffix = '';
  let core = aaChange;
  const synMatch = core.match(/\(syn\)$/);
  if (synMatch) { suffix = '(syn)'; core = core.replace(/\(syn\)$/, ''); }
  // Parse pattern: AminoAcid(s) + position + AminoAcid(s), e.g. E628K → K628E
  const match = core.match(/^([A-Z*]+)(\d+)([A-Z*]+)$/);
  if (!match) return aaChange;
  return `${match[3]}${match[2]}${match[1]}${suffix}`;
}

function applyFilters() {
  const f = getFilters();

  // First, apply fixed variant handling (flip/mask) then standard filters
  let working = state.variants;
  if (f.fixedMode === 'mask') {
    working = working.filter(v => v.af === null || v.af < 0.5);
  } else if (f.fixedMode === 'flip') {
    working = working.map(v => {
      if (v.af !== null && v.af >= 0.5) {
        // Swap ref/alt, invert AF, and flip the amino acid annotation
        return { ...v, ref: v.alt, alt: v.ref, af: 1 - v.af, aaChange: flipAaChange(v.aaChange), _flippedByToggle: true };
      }
      return v;
    });
  }

  state.filtered = working.filter(v => {
    if (v.af !== null && (v.af < f.afMin || v.af > f.afMax)) return false;
    if (v.dp !== null && v.dp < f.dpMin) return false;
    if (f.gene && v.gene !== f.gene) return false;
    if (f.type && v.type !== f.type) return false;
    if (f.isnvOnly && (v.af === null || v.af >= 0.5)) return false;
    return true;
  });
  state.aggregated = aggregateVariants(state.filtered);
  if (f.countMin > 0) state.aggregated = state.aggregated.filter(a => a.count >= f.countMin);
  updateSummary(); updatePlot(); updateTable(); updateHistogram();
  if (activeTab === 'analyses') {
    updateVPS();
    updateSFS();
    updateMutSpectrum();
    updateDnDs();
  } else {
    analysesNeedUpdate = true;
  }
}

afMinEl.addEventListener('change', applyFilters);
afMaxEl.addEventListener('change', applyFilters);
dpMinEl.addEventListener('change', applyFilters);
filterGene.addEventListener('change', applyFilters);
filterType.addEventListener('change', applyFilters);
filterIsnv.addEventListener('change', applyFilters);
countMinEl.addEventListener('change', applyFilters);

// Fixed variant toggle
const fixedToggle = document.getElementById('fixed-toggle');
fixedToggle.addEventListener('click', (e) => {
  const btn = e.target.closest('button');
  if (!btn) return;
  fixedToggle.querySelectorAll('button').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  state.fixedMode = btn.dataset.value;
  applyFilters();
});

// Plot mode toggle
const plotModeToggle = document.getElementById('plot-mode-toggle');
plotModeToggle.addEventListener('click', (e) => {
  const btn = e.target.closest('button');
  if (!btn) return;
  plotModeToggle.querySelectorAll('button').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  state.plotMode = btn.dataset.value;
  plotInitialized = false;
  updatePlot();
});

document.getElementById('filter-reset').addEventListener('click', () => {
  afMinEl.value = 0; afMaxEl.value = 1;
  dpMinEl.value = 0; filterGene.value = ''; filterType.value = '';
  filterIsnv.checked = false;
  countMinEl.value = 0;
  state.fixedMode = 'keep';
  fixedToggle.querySelectorAll('button').forEach(b => b.classList.remove('active'));
  fixedToggle.querySelector('[data-value="keep"]').classList.add('active');
  state.plotMode = 'count';
  plotModeToggle.querySelectorAll('button').forEach(b => b.classList.remove('active'));
  plotModeToggle.querySelector('[data-value="count"]').classList.add('active');
  state.tableMode = 'aggregated'; state.selectedVariantKey = null;
  applyFilters();
});

// ============================================================
// SUMMARY
// ============================================================
function updateSummary() {
  const d = state.aggregated;
  document.getElementById('sum-total').textContent = d.length;
  document.getElementById('sum-syn').textContent = d.filter(v => v.type === 'syn').length;
  document.getElementById('sum-nonsyn').textContent = d.filter(v => v.type === 'nonsyn').length;
  document.getElementById('sum-intergenic').textContent = d.filter(v => v.type === 'intergenic').length;
  const afs = state.filtered.filter(v => v.af !== null).map(v => v.af);
  document.getElementById('sum-af').textContent = afs.length ? (afs.reduce((a,b) => a+b, 0) / afs.length).toFixed(4) : '-';
}

// ============================================================
// GENOME PLOT
// ============================================================
function buildGeneShapes() {
  return state.genes.map(g => ({
    type: 'rect', xref: 'x', yref: 'paper',
    x0: g.start, x1: g.end, y0: -0.12, y1: -0.04,
    fillcolor: g.color, opacity: 0.6, line: { width: 0 },
  }));
}
function buildGeneAnnotations() {
  return state.genes.map(g => ({
    x: (g.start + g.end) / 2, y: -0.08, xref: 'x', yref: 'paper',
    text: g.name, showarrow: false, font: { size: 10, color: '#ccc' },
    captureevents: true,
  }));
}

function getGenomeRange() {
  if (state.genomeLength > 0) return [1, state.genomeLength];
  if (state.genes.length > 0) return [1, Math.max(...state.genes.map(g => g.end)) * 1.05];
  if (state.aggregated.length > 0) return [1, Math.max(...state.aggregated.map(v => v.pos)) * 1.05];
  return [1, 10000];
}

let plotInitialized = false;

function updatePlot() {
  const d = state.aggregated;
  if (d.length === 0 && state.filtered.length === 0 && !plotInitialized) { initEmptyPlot(); return; }

  const isAFMode = state.plotMode === 'af';
  const typeNames = { syn: 'Synonymous', nonsyn: 'Nonsynonymous', intergenic: 'Intergenic', unknown: 'Unknown' };
  const groups = {};
  for (const type of ['syn', 'nonsyn', 'intergenic', 'unknown'])
    groups[type] = { x: [], y: [], text: [], keys: [], sizes: [] };

  if (isAFMode) {
    // Plot each individual variant (per-sample) with AF on y-axis
    for (const v of state.filtered) {
      const t = v.type;
      if (!groups[t]) groups[t] = { x: [], y: [], text: [], keys: [], sizes: [] };
      groups[t].x.push(v.pos);
      groups[t].y.push(v.af != null ? v.af : 0);
      groups[t].keys.push(variantKey(v));
      groups[t].text.push(
        `Pos: ${v.pos} ${v.ref}>${v.alt}<br>Sample: ${v.file}<br>Gene: ${v.gene}<br>` +
        (v.aaChange ? `${v.aaChange}<br>` : '') +
        `AF: ${v.af != null ? v.af.toFixed(4) : 'N/A'}<br>DP: ${v.dp != null ? v.dp : 'N/A'}`
      );
      groups[t].sizes.push(7);
    }
  } else {
    // Plot aggregated variants with sample count on y-axis
    const maxCount = Math.max(1, ...d.map(v => v.count));
    for (const v of d) {
      const t = v.type;
      if (!groups[t]) groups[t] = { x: [], y: [], text: [], keys: [], sizes: [] };
      groups[t].x.push(v.pos);
      groups[t].y.push(v.count);
      groups[t].keys.push(v.key);
      groups[t].text.push(
        `Pos: ${v.pos} ${v.ref}>${v.alt}<br>Gene: ${v.gene}<br>` +
        (v.aaChange ? `${v.aaChange}<br>` : '') +
        `Samples: ${v.count}<br>Mean AF: ${v.meanAF != null ? v.meanAF.toFixed(4) : 'N/A'}`
      );
      groups[t].sizes.push(Math.max(6, 6 + (v.count / maxCount) * 14));
    }
  }

  const traces = [];
  for (const [type, g] of Object.entries(groups)) {
    if (g.x.length === 0) continue;
    traces.push({
      x: g.x, y: g.y, text: g.text, customdata: g.keys,
      type: 'scatter', mode: 'markers', name: typeNames[type] || type,
      marker: { color: TYPE_COLORS[type], size: g.sizes, opacity: isAFMode ? 0.5 : 0.8,
        line: { width: 0.5, color: 'rgba(255,255,255,0.3)' } },
      hoverinfo: 'text',
    });
  }

  const xRange = getGenomeRange();
  let yaxis;
  if (isAFMode) {
    yaxis = { title: 'Allele Frequency', range: [-0.02, 1.02], gridcolor: 'rgba(255,255,255,0.05)', zerolinecolor: 'rgba(255,255,255,0.1)' };
  } else {
    const yMax = Math.max(1, ...d.map(v => v.count));
    yaxis = { title: 'Sample Count', range: [-0.5, yMax * 1.1], gridcolor: 'rgba(255,255,255,0.05)', zerolinecolor: 'rgba(255,255,255,0.1)', dtick: yMax <= 10 ? 1 : undefined };
  }

  const layout = {
    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
    font: { color: '#e0e0e8', family: '-apple-system, BlinkMacSystemFont, sans-serif' },
    xaxis: { title: 'Genome Position', range: xRange, gridcolor: 'rgba(255,255,255,0.05)', zerolinecolor: 'rgba(255,255,255,0.1)' },
    yaxis,
    margin: { t: 20, b: 70, l: 60, r: 20 },
    shapes: buildGeneShapes(), annotations: buildGeneAnnotations(),
    legend: { orientation: 'h', y: 1.08, x: 0.5, xanchor: 'center', bgcolor: 'rgba(0,0,0,0)', font: { size: 11 } },
    hovermode: 'closest',
  };
  const config = { responsive: true, displayModeBar: true, modeBarButtonsToRemove: ['select2d', 'lasso2d'], displaylogo: false };

  if (!plotInitialized) {
    Plotly.newPlot('genome-plot', traces, layout, config);
    plotInitialized = true;
    const plotEl = document.getElementById('genome-plot');
    plotEl.on('plotly_click', onPlotClick);
    plotEl.on('plotly_clickannotation', onGeneClick);
  } else {
    Plotly.react('genome-plot', traces, layout, config);
  }
}

function initEmptyPlot() {
  const xRange = getGenomeRange();
  const layout = {
    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
    font: { color: '#e0e0e8', family: '-apple-system, BlinkMacSystemFont, sans-serif' },
    xaxis: { title: 'Genome Position', range: xRange, gridcolor: 'rgba(255,255,255,0.05)' },
    yaxis: { title: 'Sample Count', range: [-0.5, 10], gridcolor: 'rgba(255,255,255,0.05)' },
    margin: { t: 20, b: 70, l: 60, r: 20 },
    shapes: buildGeneShapes(),
    annotations: [
      ...buildGeneAnnotations(),
      { x: (xRange[0] + xRange[1]) / 2, y: 5, xref: 'x', yref: 'y',
        text: 'Drop VCF files above to visualize variants',
        showarrow: false, font: { size: 14, color: '#888' } },
    ],
  };
  Plotly.newPlot('genome-plot', [], layout, { responsive: true, displaylogo: false });
  plotInitialized = true;
  const plotEl = document.getElementById('genome-plot');
  plotEl.on('plotly_click', onPlotClick);
  plotEl.on('plotly_clickannotation', onGeneClick);
}

function onPlotClick(data) {
  if (!data.points || !data.points.length) return;
  const key = data.points[0].customdata;
  if (key) selectVariant(key);
}

function onGeneClick(data) {
  const geneName = data.annotation.text;
  const gene = state.genes.find(g => g.name === geneName);
  if (!gene) return;
  // Set gene filter and zoom plot to gene coordinates
  filterGene.value = geneName;
  applyFilters();
  // Zoom x-axis to gene region with some padding
  const pad = (gene.end - gene.start) * 0.05;
  Plotly.relayout('genome-plot', { 'xaxis.range': [gene.start - pad, gene.end + pad] });
}

// ============================================================
// FREQUENCY HISTOGRAM
// ============================================================
let histInitialized = false;

function updateHistogram() {
  const topN = parseInt(document.getElementById('hist-top-n').value, 10) || 20;
  const sorted = [...state.aggregated].sort((a, b) => b.count - a.count).slice(0, topN).reverse();

  if (sorted.length === 0) {
    if (!histInitialized) {
      Plotly.newPlot('freq-histogram', [], {
        paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#e0e0e8', family: '-apple-system, BlinkMacSystemFont, sans-serif' },
        xaxis: { title: 'Sample Count', gridcolor: 'rgba(255,255,255,0.05)' },
        yaxis: { gridcolor: 'rgba(255,255,255,0.05)' },
        margin: { t: 10, b: 40, l: 200, r: 20 },
        annotations: [{ x: 0.5, y: 0.5, xref: 'paper', yref: 'paper',
          text: 'No variants to display', showarrow: false, font: { size: 14, color: '#888' } }],
      }, { responsive: true, displaylogo: false });
      histInitialized = true;
      document.getElementById('freq-histogram').on('plotly_click', onHistClick);
    }
    return;
  }

  const labels = sorted.map(v => {
    let label = `${v.ref}${v.pos}${v.alt}`;
    if (v.gene && v.gene !== 'intergenic') label += ` (${v.gene}`;
    else if (v.gene === 'intergenic') label += ' (intergenic';
    if (v.aaChange && v.aaChange !== 'intergenic') label += `:${v.aaChange}`;
    if (v.gene) label += ')';
    return label;
  });
  const colors = sorted.map(v => TYPE_COLORS[v.type] || TYPE_COLORS.unknown);
  const keys = sorted.map(v => v.key);

  const trace = {
    y: labels,
    x: sorted.map(v => v.count),
    customdata: keys,
    type: 'bar',
    orientation: 'h',
    marker: { color: colors, opacity: 0.85, line: { width: 0.5, color: 'rgba(255,255,255,0.2)' } },
    text: sorted.map(v => v.count),
    textposition: 'outside',
    textfont: { color: '#e0e0e8', size: 11 },
    hovertext: sorted.map(v =>
      `${v.ref}${v.pos}${v.alt}<br>Gene: ${v.gene}<br>` +
      (v.aaChange ? `${v.aaChange}<br>` : '') +
      `Samples: ${v.count}<br>Mean AF: ${v.meanAF != null ? v.meanAF.toFixed(4) : 'N/A'}`
    ),
    hoverinfo: 'text',
  };

  const barHeight = Math.max(500, sorted.length * 24);
  const layout = {
    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
    font: { color: '#e0e0e8', family: '-apple-system, BlinkMacSystemFont, sans-serif' },
    xaxis: {
      title: 'Sample Count', gridcolor: 'rgba(255,255,255,0.08)',
      zerolinecolor: 'rgba(255,255,255,0.1)',
      tickmode: 'linear', dtick: Math.max(1, Math.ceil(Math.max(...sorted.map(v => v.count)) / 10)),
      tickfont: { size: 12 }, side: 'top',
    },
    yaxis: { automargin: true, gridcolor: 'rgba(255,255,255,0.05)', tickfont: { size: 11 } },
    margin: { t: 40, b: 10, l: 10, r: 40 },
    height: barHeight,
    bargap: 0.15,
  };

  document.getElementById('freq-histogram').style.height = barHeight + 'px';

  if (!histInitialized) {
    Plotly.newPlot('freq-histogram', [trace], layout, { responsive: true, displayModeBar: false, displaylogo: false });
    histInitialized = true;
    document.getElementById('freq-histogram').on('plotly_click', onHistClick);
  } else {
    Plotly.react('freq-histogram', [trace], layout);
  }
}

function onHistClick(data) {
  if (!data.points || !data.points.length) return;
  const key = data.points[0].customdata;
  if (key) selectVariant(key);
}

document.getElementById('hist-top-n').addEventListener('change', updateHistogram);

function highlightPlotPoint(agg) {
  const plotEl = document.getElementById('genome-plot');
  if (!plotEl.data || !plotEl.data.length) return;
  const traces = plotEl.data.filter(t => t.name !== '_highlight');
  traces.push({
    x: [agg.pos], y: [agg.count], type: 'scatter', mode: 'markers',
    marker: { color: 'rgba(255,255,255,0)', size: 20, line: { color: '#fff', width: 2.5 } },
    hoverinfo: 'skip', showlegend: false, name: '_highlight',
  });
  Plotly.react('genome-plot', traces, plotEl.layout);
}

function clearPlotHighlight() {
  const plotEl = document.getElementById('genome-plot');
  if (plotEl.data) {
    Plotly.react('genome-plot', plotEl.data.filter(t => t.name !== '_highlight'), plotEl.layout);
  }
}

// ============================================================
// DATA TABLE
// ============================================================
const aggColumns = [
  { title: 'POS', field: 'pos', headerFilter: 'input', sorter: 'number', minWidth: 70 },
  { title: 'REF', field: 'ref', headerFilter: 'input', minWidth: 50 },
  { title: 'ALT', field: 'alt', headerFilter: 'input', minWidth: 50 },
  { title: 'Gene', field: 'gene', headerFilter: 'input', minWidth: 70 },
  { title: 'Annotation', field: 'aaChange', headerFilter: 'input', minWidth: 120,
    formatter: c => c.getValue() || '-' },
  { title: 'Type', field: 'type', headerFilter: 'input', minWidth: 90,
    formatter: c => {
      const t = c.getValue();
      const labels = { syn: 'SYN', nonsyn: 'NONSYN', intergenic: 'INTER', unknown: 'UNK' };
      return `<span class="type-badge type-${t}">${labels[t] || t}</span>`;
    }
  },
  { title: 'Count', field: 'count', headerFilter: 'input', sorter: 'number', minWidth: 70, formatter: c => '<b>' + c.getValue() + '</b>' },
  { title: 'Mean Allele Freq', field: 'meanAF', headerFilter: 'input', sorter: 'number', minWidth: 80,
    formatter: c => { const v = c.getValue(); return v != null ? v.toFixed(4) : '-'; } },
  { title: 'Min Allele Freq', field: 'minAF', sorter: 'number', minWidth: 75,
    formatter: c => { const v = c.getValue(); return v != null ? v.toFixed(4) : '-'; } },
  { title: 'Max Allele Freq', field: 'maxAF', sorter: 'number', minWidth: 75,
    formatter: c => { const v = c.getValue(); return v != null ? v.toFixed(4) : '-'; } },
];

function buildDetailColumns() {
  const cols = [
    { title: 'Sample', field: 'file', headerFilter: 'input', minWidth: 120 },
    { title: 'Allele Frequency', field: 'af', headerFilter: 'input', sorter: 'number', minWidth: 70,
      formatter: c => { const v = c.getValue(); return v != null ? v.toFixed(4) : '-'; } },
    { title: 'Depth', field: 'dp', headerFilter: 'input', sorter: 'number', minWidth: 60 },
    { title: 'Filter', field: 'filter', headerFilter: 'input', minWidth: 70 },
    { title: 'Strand Bias', field: 'sb', headerFilter: 'input', sorter: 'number', minWidth: 50 },
    { title: 'DP4', field: 'dp4', headerFilter: 'input', minWidth: 100,
      headerTooltip: 'Ref-Forward, Ref-Reverse, Alt-Forward, Alt-Reverse',
      formatter: c => {
        const v = c.getValue();
        if (!v) return '-';
        const parts = v.split(',');
        if (parts.length === 4) {
          return `<span title="Ref-Fwd: ${parts[0]}, Ref-Rev: ${parts[1]}, Alt-Fwd: ${parts[2]}, Alt-Rev: ${parts[3]}">${v}</span>`;
        }
        return v;
      }
    },
  ];
  if (state.hasCleaned) {
    cols.push(
      { title: 'Flipped', field: 'flipped', headerFilter: 'input', minWidth: 70,
        formatter: c => c.getValue() ? '<span class="flipped-badge">YES</span>' : '' },
      { title: 'P-value', field: 'pvalCorr', headerFilter: 'input', sorter: 'number', minWidth: 80,
        formatter: c => { const v = c.getValue(); if (v == null) return '-'; return v < 0.001 ? v.toExponential(2) : v.toFixed(4); } },
    );
  }
  return cols;
}

function initTable() {
  state.table = new Tabulator('#variant-table', {
    data: [], columns: aggColumns, layout: 'fitColumns', height: '450px',
    pagination: 'local', paginationSize: 50, paginationCounter: 'rows',
    movableColumns: true, initialSort: [{ column: 'pos', dir: 'asc' }],
    placeholder: 'No variants loaded. Drop VCF files above to begin.',
  });
  state.table.on('rowClick', (e, row) => {
    if (state.tableMode === 'aggregated') selectVariant(row.getData().key);
  });
}

function updateTable() {
  if (!state.table) return;
  const backBtn = document.getElementById('back-btn');
  const tableTitle = document.getElementById('table-title');

  if (state.tableMode === 'detail' && state.selectedVariantKey) {
    const agg = state.aggregated.find(a => a.key === state.selectedVariantKey);
    if (!agg) { state.tableMode = 'aggregated'; updateTable(); return; }
    backBtn.style.display = 'inline-block';
    tableTitle.textContent = `Samples with ${agg.ref}${agg.pos}${agg.alt} (${agg.gene})`;
    state.table.setColumns(buildDetailColumns());
    state.table.replaceData(agg.samples.map(s => ({...s})));
    document.getElementById('table-count').textContent = `${agg.samples.length} sample${agg.samples.length !== 1 ? 's' : ''}`;
  } else {
    backBtn.style.display = 'none';
    tableTitle.textContent = 'Variant Table';
    state.tableMode = 'aggregated';
    state.table.setColumns(aggColumns);
    state.table.replaceData(state.aggregated.map(a => ({...a})));
    document.getElementById('table-count').textContent = `${state.aggregated.length} unique variant${state.aggregated.length !== 1 ? 's' : ''}`;
  }
}

document.getElementById('back-btn').addEventListener('click', () => {
  state.tableMode = 'aggregated'; state.selectedVariantKey = null;
  clearPlotHighlight(); updateTable();
});

// ============================================================
// SELECT VARIANT
// ============================================================
function selectVariant(key) {
  const agg = state.aggregated.find(a => a.key === key);
  if (!agg) return;
  state.selectedVariantKey = key;
  state.tableMode = 'detail';
  highlightPlotPoint(agg);
  updateTable();
  showDetailModal(agg);
}

// ============================================================
// DETAIL MODAL
// ============================================================
function showDetailModal(agg) {
  const body = document.getElementById('modal-body');
  let html = '<div class="modal-grid">';
  const fields = [
    { label: 'Position', value: agg.pos },
    { label: 'Change', value: `${agg.ref} &rarr; ${agg.alt}` },
    { label: 'Gene', value: agg.gene },
    { label: 'Annotation', value: agg.aaChange || '-' },
    { label: 'Type', value: `<span class="type-badge type-${agg.type}">${agg.type.toUpperCase()}</span>` },
    { label: 'Sample Count', value: `<b>${agg.count}</b>` },
    { label: 'Mean AF', value: agg.meanAF != null ? agg.meanAF.toFixed(4) : '-' },
    { label: 'AF Range', value: agg.minAF != null ? `${agg.minAF.toFixed(4)} - ${agg.maxAF.toFixed(4)}` : '-' },
  ];
  html += fields.map(f => `<div class="modal-field"><div class="mf-label">${f.label}</div><div class="mf-value">${f.value}</div></div>`).join('');
  html += '</div>';
  html += `<div class="modal-section-title">Found in ${agg.count} sample${agg.count !== 1 ? 's' : ''}</div>`;
  html += '<table class="sample-list"><thead><tr><th>Sample</th><th>AF</th><th>DP</th><th>Filter</th>';
  if (state.hasCleaned) html += '<th>Flipped</th><th>P-val</th>';
  html += '</tr></thead><tbody>';
  const sorted = [...agg.samples].sort((a, b) => (b.af || 0) - (a.af || 0));
  for (const s of sorted) {
    html += `<tr><td>${s.file}</td><td>${s.af != null ? s.af.toFixed(4) : '-'}</td><td>${s.dp != null ? s.dp : '-'}</td><td>${s.filter}</td>`;
    if (state.hasCleaned) html += `<td>${s.flipped ? '<span class="flipped-badge">YES</span>' : ''}</td><td>${s.pvalCorr != null ? s.pvalCorr.toExponential(2) : '-'}</td>`;
    html += '</tr>';
  }
  html += '</tbody></table>';
  body.innerHTML = html;
  document.getElementById('modal-overlay').classList.add('active');
}

document.getElementById('modal-close').addEventListener('click', () => document.getElementById('modal-overlay').classList.remove('active'));
document.getElementById('modal-overlay').addEventListener('click', (e) => { if (e.target === e.currentTarget) document.getElementById('modal-overlay').classList.remove('active'); });
document.addEventListener('keydown', (e) => { if (e.key === 'Escape') document.getElementById('modal-overlay').classList.remove('active'); });

// ============================================================
// EXPORT
// ============================================================
function exportTable(separator, ext) {
  if (state.tableMode === 'detail' && state.selectedVariantKey) {
    const agg = state.aggregated.find(a => a.key === state.selectedVariantKey);
    if (!agg) return;
    const cols = ['file', 'pos', 'ref', 'alt', 'af', 'dp', 'gene', 'aaChange', 'type', 'filter', 'sb', 'dp4'];
    if (state.hasCleaned) cols.push('flipped', 'pval', 'pvalCorr', 'passBinom');
    const headers = { file: 'Sample', pos: 'POS', ref: 'REF', alt: 'ALT', af: 'AF', dp: 'DP', gene: 'Gene', aaChange: 'Annotation', type: 'Type', filter: 'Filter', sb: 'SB', dp4: 'DP4', flipped: 'Flipped', pval: 'P-value', pvalCorr: 'P-value_corr', passBinom: 'PASS_BINOM' };
    let content = cols.map(c => headers[c] || c).join(separator) + '\n';
    for (const s of agg.samples) {
      content += cols.map(c => { let v = s[c]; if (v == null) return ''; if (typeof v === 'boolean') return v ? 'true' : 'false'; if (typeof v === 'number' && c === 'af') return v.toFixed(6); return String(v); }).join(separator) + '\n';
    }
    downloadFile(content, `variant_${agg.pos}_${agg.ref}_${agg.alt}_samples.${ext}`);
  } else {
    const cols = ['pos', 'ref', 'alt', 'gene', 'aaChange', 'type', 'count', 'meanAF', 'minAF', 'maxAF'];
    const headers = { pos: 'POS', ref: 'REF', alt: 'ALT', gene: 'Gene', aaChange: 'Annotation', type: 'Type', count: 'Sample_Count', meanAF: 'Mean_AF', minAF: 'Min_AF', maxAF: 'Max_AF' };
    let content = cols.map(c => headers[c] || c).join(separator) + '\n';
    for (const a of state.aggregated) {
      content += cols.map(c => { let v = a[c]; if (v == null) return ''; if (typeof v === 'number' && (c === 'meanAF' || c === 'minAF' || c === 'maxAF')) return v.toFixed(6); return String(v); }).join(separator) + '\n';
    }
    downloadFile(content, `variants_aggregated.${ext}`);
  }
}

function downloadFile(content, filename) {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

document.getElementById('export-csv').addEventListener('click', () => exportTable(',', 'csv'));
document.getElementById('export-tsv').addEventListener('click', () => exportTable('\t', 'tsv'));
document.getElementById('export-png').addEventListener('click', () => Plotly.downloadImage('genome-plot', { format: 'png', width: 1600, height: 500, filename: 'genome_plot' }));
document.getElementById('export-svg').addEventListener('click', () => Plotly.downloadImage('genome-plot', { format: 'svg', width: 1600, height: 500, filename: 'genome_plot' }));

// ============================================================
// VARIANTS PER SAMPLE
// ============================================================
var vpsTypeToggle = document.getElementById('vps-type-toggle');
vpsTypeToggle.addEventListener('click', function(e) {
  var btn = e.target.closest('button');
  if (!btn) return;
  vpsTypeToggle.querySelectorAll('button').forEach(function(b) { b.classList.remove('active'); });
  btn.classList.add('active');
  vpsTypeFilter = btn.dataset.value;
  updateVPS();
});

function updateVPS() {
  var data = state.filtered;
  if (vpsTypeFilter !== 'all') {
    data = data.filter(function(v) { return v.type === vpsTypeFilter; });
  }

  // Count variants per sample
  var sampleCounts = {};
  var i;
  for (i = 0; i < data.length; i++) {
    var s = data[i].file;
    sampleCounts[s] = (sampleCounts[s] || 0) + 1;
  }
  // Include samples with 0 variants for this filter
  for (i = 0; i < state.fileNames.length; i++) {
    var name = sampleName(state.fileNames[i]);
    if (sampleCounts[name] === undefined) sampleCounts[name] = 0;
  }

  var samples = Object.keys(sampleCounts);
  var values = samples.map(function(s) { return sampleCounts[s]; });

  // Compute mean and median
  var mean = 0;
  var median = 0;
  if (values.length > 0) {
    var sum = 0;
    for (i = 0; i < values.length; i++) sum += values[i];
    mean = sum / values.length;
    var sorted = values.slice().sort(function(a, b) { return a - b; });
    var mid = Math.floor(sorted.length / 2);
    median = sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
  }

  var typeBarColors = colorblindMode ? CB_TYPE_BAR_COLORS : DEFAULT_TYPE_BAR_COLORS;
  var barColor = typeBarColors[vpsTypeFilter] || typeBarColors.all;

  var trace = {
    x: values, type: 'histogram',
    marker: { color: barColor, opacity: 0.85, line: { width: 1, color: 'rgba(255,255,255,0.2)' } },
    hovertemplate: 'Variants: %{x}<br>Samples: %{y}<extra></extra>'
  };

  var maxVal = values.length > 0 ? Math.max.apply(null, values) : 10;

  var shapes = [];
  var annotations = [];
  if (values.length > 0) {
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: mean, x1: mean, y0: 0, y1: 1,
      line: { color: '#f0c040', width: 2, dash: 'dot' }
    });
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: median, x1: median, y0: 0, y1: 1,
      line: { color: '#55b87a', width: 2, dash: 'dot' }
    });
    annotations.push({
      x: mean, y: 1.06, xref: 'x', yref: 'paper',
      text: 'Mean: ' + mean.toFixed(1), showarrow: false,
      font: { size: 11, color: '#f0c040' }
    });
    annotations.push({
      x: median, y: 1.12, xref: 'x', yref: 'paper',
      text: 'Median: ' + median.toFixed(1), showarrow: false,
      font: { size: 11, color: '#55b87a' }
    });
  }

  var layout = {
    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
    font: { color: '#e0e0e8', family: '-apple-system, BlinkMacSystemFont, sans-serif' },
    xaxis: { title: 'Number of Variants', gridcolor: 'rgba(255,255,255,0.05)', zerolinecolor: 'rgba(255,255,255,0.1)' },
    yaxis: { title: 'Number of Samples', gridcolor: 'rgba(255,255,255,0.05)', zerolinecolor: 'rgba(255,255,255,0.1)' },
    margin: { t: 40, b: 60, l: 60, r: 20 },
    shapes: shapes,
    annotations: annotations,
    bargap: 0.08
  };
  var config = { responsive: true, displayModeBar: true, displaylogo: false };

  if (!vpsInitialized) {
    Plotly.newPlot('vps-plot', [trace], layout, config);
    vpsInitialized = true;
  } else {
    Plotly.react('vps-plot', [trace], layout, config);
  }
}

// ============================================================
// TAB NAVIGATION
// ============================================================
var mainTabToggle = document.getElementById('main-tab-toggle');
mainTabToggle.addEventListener('click', function(e) {
  var btn = e.target.closest('button');
  if (!btn) return;
  mainTabToggle.querySelectorAll('button').forEach(function(b) { b.classList.remove('active'); });
  btn.classList.add('active');
  switchTab(btn.dataset.tab);
});

function switchTab(tab) {
  activeTab = tab;
  document.getElementById('tab-browser').style.display = tab === 'browser' ? 'block' : 'none';
  document.getElementById('tab-analyses').style.display = tab === 'analyses' ? 'block' : 'none';
  if (tab === 'analyses' && analysesNeedUpdate) {
    updateVPS();
    updateSFS();
    updateMutSpectrum();
    updateDnDs();
    analysesNeedUpdate = false;
  }
}

// ============================================================
// SITE FREQUENCY SPECTRUM
// ============================================================
var sfsTypeToggle = document.getElementById('sfs-type-toggle');
sfsTypeToggle.addEventListener('click', function(e) {
  var btn = e.target.closest('button');
  if (!btn) return;
  sfsTypeToggle.querySelectorAll('button').forEach(function(b) { b.classList.remove('active'); });
  btn.classList.add('active');
  sfsTypeFilter = btn.dataset.value;
  updateSFS();
});

function sfsSummary(counts, expected, binCenters, totalObs) {
  if (totalObs === 0) return '';
  // Partition bins into low (AF<0.2), mid (0.2-0.8), high (>0.8)
  var obsLow = 0, expLow = 0, obsMid = 0, expMid = 0, obsHigh = 0, expHigh = 0;
  for (var i = 0; i < counts.length; i++) {
    if (binCenters[i] < 0.2) { obsLow += counts[i]; expLow += expected[i]; }
    else if (binCenters[i] > 0.8) { obsHigh += counts[i]; expHigh += expected[i]; }
    else { obsMid += counts[i]; expMid += expected[i]; }
  }
  var notes = [];
  // Describe overall shape
  if (expLow > 0 && obsLow / expLow > 1.3) {
    notes.push('Excess of rare variants (AF &lt; 0.2) relative to neutral expectation \u2014 consistent with purifying selection or recent population expansion.');
  } else if (expLow > 0 && obsLow / expLow < 0.7) {
    notes.push('Deficit of rare variants (AF &lt; 0.2) \u2014 may suggest a recent bottleneck reducing low-frequency diversity.');
  }
  if (expMid > 0 && obsMid / expMid > 1.5) {
    notes.push('Enrichment of intermediate-frequency variants (0.2\u20130.8) \u2014 could indicate balancing selection, population structure, or mixed infections.');
  }
  if (expHigh > 0 && obsHigh / expHigh > 1.5) {
    notes.push('Excess of high-frequency variants (AF &gt; 0.8) \u2014 may reflect positive selection or a transmission bottleneck driving variants toward fixation.');
  }
  if (notes.length === 0) {
    notes.push('The observed SFS broadly follows the neutral 1/f expectation.');
  }
  return '<b>Shape summary:</b> ' + notes.join(' ');
}

function updateSFS() {
  var data = state.filtered;
  if (sfsTypeFilter !== 'all') {
    data = data.filter(function(v) { return v.type === sfsTypeFilter; });
  }

  var afs = data.filter(function(v) { return v.af != null; }).map(function(v) { return v.af; });

  var nBins = 20;
  var binWidth = 1 / nBins;
  var counts = new Array(nBins).fill(0);
  var i, bin;
  for (i = 0; i < afs.length; i++) {
    bin = Math.floor(afs[i] / binWidth);
    if (bin >= nBins) bin = nBins - 1;
    counts[bin]++;
  }

  var binCenters = [];
  var binLabels = [];
  for (i = 0; i < nBins; i++) {
    binCenters.push((i + 0.5) * binWidth);
    binLabels.push((i * binWidth).toFixed(2) + '-' + ((i + 1) * binWidth).toFixed(2));
  }

  var totalObs = counts.reduce(function(a, b) { return a + b; }, 0);
  var rawExpected = binCenters.map(function(f) { return 1 / f; });
  var rawSum = rawExpected.reduce(function(a, b) { return a + b; }, 0);
  var normC = rawSum > 0 ? totalObs / rawSum : 0;
  var expected = rawExpected.map(function(e) { return e * normC; });

  var typeBarColors = colorblindMode ? CB_TYPE_BAR_COLORS : DEFAULT_TYPE_BAR_COLORS;
  var barColor = typeBarColors[sfsTypeFilter] || typeBarColors.all;

  var traces = [
    {
      x: binLabels, y: counts, type: 'bar', name: 'Observed',
      marker: { color: barColor, opacity: 0.85 },
      hovertemplate: 'AF bin: %{x}<br>Observed: %{y}<extra></extra>'
    },
    {
      x: binLabels, y: expected, type: 'scatter', mode: 'lines+markers',
      name: 'Neutral (1/f)', line: { color: '#f0c040', width: 2, dash: 'dot' },
      marker: { color: '#f0c040', size: 5 },
      hovertemplate: 'AF bin: %{x}<br>Neutral expected: %{y:.1f}<extra></extra>'
    }
  ];

  // Compute overall shape summary
  var shapeSummary = sfsSummary(counts, expected, binCenters, totalObs);

  var layout = {
    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
    font: { color: '#e0e0e8', family: '-apple-system, BlinkMacSystemFont, sans-serif' },
    xaxis: { title: 'Allele Frequency Bin', gridcolor: 'rgba(255,255,255,0.05)', tickangle: -45, tickfont: { size: 10 } },
    yaxis: { title: 'Count', gridcolor: 'rgba(255,255,255,0.05)', zerolinecolor: 'rgba(255,255,255,0.1)' },
    margin: { t: 20, b: 80, l: 60, r: 20 },
    legend: { orientation: 'h', y: 1.08, x: 0.5, xanchor: 'center', bgcolor: 'rgba(0,0,0,0)', font: { size: 11 } },
    bargap: 0.08
  };
  var config = { responsive: true, displayModeBar: true, displaylogo: false };

  if (!sfsInitialized) {
    Plotly.newPlot('sfs-plot', traces, layout, config);
    sfsInitialized = true;
  } else {
    Plotly.react('sfs-plot', traces, layout, config);
  }

  // Update shape summary text below the plot
  document.getElementById('sfs-summary').innerHTML = shapeSummary;
}

// ============================================================
// MUTATIONAL SPECTRUM
// ============================================================
var mutTypeToggle = document.getElementById('mut-type-toggle');
mutTypeToggle.addEventListener('click', function(e) {
  var btn = e.target.closest('button');
  if (!btn) return;
  mutTypeToggle.querySelectorAll('button').forEach(function(b) { b.classList.remove('active'); });
  btn.classList.add('active');
  mutTypeFilter = btn.dataset.value;
  updateMutSpectrum();
});

function updateMutSpectrum() {
  var data = state.filtered;
  if (mutTypeFilter !== 'all') {
    data = data.filter(function(v) { return v.type === mutTypeFilter; });
  }

  // Only single-base substitutions
  var subs = data.filter(function(v) { return v.ref.length === 1 && v.alt.length === 1; });

  // Count all 12 substitution types
  var counts = {};
  var i;
  for (i = 0; i < MUT_CATEGORIES.length; i++) counts[MUT_CATEGORIES[i]] = 0;

  for (i = 0; i < subs.length; i++) {
    var ref = subs[i].ref.toUpperCase();
    var alt = subs[i].alt.toUpperCase();
    var key = ref + '>' + alt;
    if (counts[key] !== undefined) {
      counts[key]++;
    }
  }

  var x = MUT_CATEGORIES;
  var y = MUT_CATEGORIES.map(function(k) { return counts[k]; });
  var colors = MUT_CATEGORIES.map(function(k) { return MUT_GROUP_COLORS[k.charAt(0)]; });

  var trace = {
    x: x, y: y, type: 'bar',
    marker: { color: colors, opacity: 0.9, line: { width: 1, color: 'rgba(255,255,255,0.3)' } },
    text: y.map(String), textposition: 'outside', textfont: { color: '#e0e0e8', size: 11 },
    hovertemplate: '%{x}<br>Count: %{y}<extra></extra>'
  };

  var layout = {
    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
    font: { color: '#e0e0e8', family: '-apple-system, BlinkMacSystemFont, sans-serif' },
    xaxis: { title: 'Substitution Type', gridcolor: 'rgba(255,255,255,0.05)', tickfont: { size: 12, color: '#e0e0e8' } },
    yaxis: { title: 'Count', gridcolor: 'rgba(255,255,255,0.05)', zerolinecolor: 'rgba(255,255,255,0.1)' },
    margin: { t: 30, b: 60, l: 60, r: 20 },
    bargap: 0.15
  };
  var config = { responsive: true, displayModeBar: true, displaylogo: false };

  if (!mutInitialized) {
    Plotly.newPlot('mut-spectrum-plot', [trace], layout, config);
    mutInitialized = true;
  } else {
    Plotly.react('mut-spectrum-plot', [trace], layout, config);
  }
}

// ============================================================
// dN/dS ANALYSIS
// ============================================================
var dndsToggle = document.getElementById('dnds-mode-toggle');
dndsToggle.addEventListener('click', function(e) {
  var btn = e.target.closest('button');
  if (!btn) return;
  dndsToggle.querySelectorAll('button').forEach(function(b) { b.classList.remove('active'); });
  btn.classList.add('active');
  dndsMode = btn.dataset.value;
  var winVis = dndsMode === 'rolling' ? '' : 'none';
  document.getElementById('dnds-window-label').style.display = winVis;
  document.getElementById('dnds-window-toggle').style.display = winVis;
  updateDnDs();
});

var dndsWinToggle = document.getElementById('dnds-window-toggle');
dndsWinToggle.addEventListener('click', function(e) {
  var btn = e.target.closest('button');
  if (!btn) return;
  dndsWinToggle.querySelectorAll('button').forEach(function(b) { b.classList.remove('active'); });
  btn.classList.add('active');
  dndsWindowSize = parseInt(btn.dataset.value, 10);
  updateDnDs();
});

function updateDnDs() {
  var plotDiv = document.getElementById('dnds-plot');
  if (!state.refSequence || state.genes.length === 0) {
    Plotly.purge(plotDiv);
    plotDiv.innerHTML = '<div style="color:var(--text-dim); text-align:center; padding:80px 20px; font-size:14px;">Load a GenBank reference to compute dN/dS.</div>';
    dndsInitialized = false;
    return;
  }
  if (!dndsInitialized) {
    plotDiv.innerHTML = '';
  }

  if (dndsMode === 'pergene') {
    updateDnDsPerGene();
  } else {
    updateDnDsRolling();
  }
}

function updateDnDsPerGene() {
  var genes = state.genes;
  var data = state.filtered;

  // Group variants by sample
  var sampleMap = {};
  for (var i = 0; i < data.length; i++) {
    var v = data[i];
    if (v.ref.length !== 1 || v.alt.length !== 1) continue;
    if (v.type !== 'syn' && v.type !== 'nonsyn') continue;
    var sn = v.sample || v.file || 'unknown';
    if (!sampleMap[sn]) sampleMap[sn] = [];
    sampleMap[sn].push(v);
  }
  var sampleNames = Object.keys(sampleMap);
  if (sampleNames.length === 0) {
    var plotDiv = document.getElementById('dnds-plot');
    Plotly.purge(plotDiv);
    plotDiv.innerHTML = '<div style="color:var(--text-dim); text-align:center; padding:80px 20px; font-size:14px;">No variant data available for dN/dS computation.</div>';
    dndsInitialized = false;
    return;
  }

  var geneNames = [], means = [], ciLow = [], ciHigh = [], nSamples = [];

  for (var gi = 0; gi < genes.length; gi++) {
    var gene = genes[gi];
    var sites = countSynNonsynSites(gene);
    if (!sites || sites.synSites === 0 || sites.nonsynSites === 0) continue;

    var dndsValues = [];
    for (var si = 0; si < sampleNames.length; si++) {
      var vars = sampleMap[sampleNames[si]];
      if (!vars) continue;
      var pS = 0, pN = 0;
      for (var vi = 0; vi < vars.length; vi++) {
        var vv = vars[vi];
        if (vv.pos < gene.start || vv.pos > gene.end) continue;
        if (vv.type === 'syn') pS++;
        else if (vv.type === 'nonsyn') pN++;
      }
      var dS = pS / sites.synSites;
      var dN = pN / sites.nonsynSites;
      if (dS === 0) continue; // skip sample if no synonymous substitutions
      dndsValues.push(dN / dS);
    }

    if (dndsValues.length === 0) continue;

    var mean = 0;
    for (var k = 0; k < dndsValues.length; k++) mean += dndsValues[k];
    mean /= dndsValues.length;

    var se = 0;
    if (dndsValues.length > 1) {
      var variance = 0;
      for (var k = 0; k < dndsValues.length; k++) variance += (dndsValues[k] - mean) * (dndsValues[k] - mean);
      variance /= (dndsValues.length - 1);
      se = Math.sqrt(variance / dndsValues.length);
    }

    geneNames.push(gene.name);
    means.push(mean);
    ciLow.push(Math.max(0, mean - 1.96 * se));
    ciHigh.push(mean + 1.96 * se);
    nSamples.push(dndsValues.length);
  }

  if (geneNames.length === 0) {
    var plotDiv = document.getElementById('dnds-plot');
    Plotly.purge(plotDiv);
    plotDiv.innerHTML = '<div style="color:var(--text-dim); text-align:center; padding:80px 20px; font-size:14px;">Insufficient data to compute dN/dS (need both syn and nonsyn variants per gene).</div>';
    dndsInitialized = false;
    return;
  }

  var barColor = colorblindMode ? '#56B4E9' : '#5b8def';
  var hoverText = [];
  for (var i = 0; i < geneNames.length; i++) {
    hoverText.push(geneNames[i] + '<br>dN/dS: ' + means[i].toFixed(3) +
      '<br>95% CI: [' + ciLow[i].toFixed(3) + ', ' + ciHigh[i].toFixed(3) + ']' +
      '<br>' + nSamples[i] + ' VCFs with ≥1 syn variant');
  }

  var errYMinus = [], errYPlus = [];
  for (var i = 0; i < means.length; i++) {
    errYMinus.push(means[i] - ciLow[i]);
    errYPlus.push(ciHigh[i] - means[i]);
  }

  var trace = {
    x: geneNames, y: means, type: 'bar',
    marker: { color: barColor, opacity: 0.9, line: { width: 1, color: 'rgba(255,255,255,0.3)' } },
    error_y: {
      type: 'data', symmetric: false,
      array: errYPlus, arrayminus: errYMinus,
      visible: true, color: '#ffffff', thickness: 1.5, width: 4
    },
    text: hoverText, hoverinfo: 'text'
  };

  var layout = {
    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
    font: { color: '#e0e0e8', family: '-apple-system, BlinkMacSystemFont, sans-serif' },
    xaxis: { title: 'Gene', gridcolor: 'rgba(255,255,255,0.05)', tickfont: { size: 11, color: '#e0e0e8' } },
    yaxis: { title: 'dN/dS', gridcolor: 'rgba(255,255,255,0.05)', zerolinecolor: 'rgba(255,255,255,0.1)' },
    margin: { t: 30, b: 60, l: 60, r: 20 },
    bargap: 0.2,
    shapes: [{
      type: 'line', xref: 'paper', x0: 0, x1: 1,
      yref: 'y', y0: 1, y1: 1,
      line: { color: '#f0c040', width: 2, dash: 'dash' }
    }],
    annotations: [{
      x: 1, xref: 'paper', xanchor: 'right',
      y: 1, yref: 'y', yanchor: 'bottom',
      text: 'neutral (dN/dS = 1)', showarrow: false,
      font: { color: '#f0c040', size: 10 }
    }]
  };
  var config = { responsive: true, displayModeBar: true, displaylogo: false };

  if (!dndsInitialized) {
    Plotly.newPlot('dnds-plot', [trace], layout, config);
    dndsInitialized = true;
  } else {
    Plotly.react('dnds-plot', [trace], layout, config);
  }
}

function updateDnDsRolling() {
  var seq = state.refSequence;
  var genes = state.genes;
  var data = state.filtered;
  var winSize = dndsWindowSize;
  var step = Math.max(1, Math.floor(winSize / 5));

  // Group variants by sample
  var sampleMap = {};
  for (var i = 0; i < data.length; i++) {
    var v = data[i];
    if (v.ref.length !== 1 || v.alt.length !== 1) continue;
    if (v.type !== 'syn' && v.type !== 'nonsyn') continue;
    var sn = v.sample || v.file || 'unknown';
    if (!sampleMap[sn]) sampleMap[sn] = [];
    sampleMap[sn].push(v);
  }
  var sampleNames = Object.keys(sampleMap);

  // Build traces per gene — slide window within each gene only
  var traces = [];
  var hasData = false;
  var geneShapes = [];
  var geneAnnotations = [];
  var palette = colorblindMode ? CB_GENE_PALETTE : GENE_PALETTE;

  for (var gi = 0; gi < genes.length; gi++) {
    var gene = genes[gi];
    var geneLen = gene.end - gene.start + 1;
    if (geneLen < winSize) continue; // gene too short for this window

    var geneColor = gene.color || palette[gi % palette.length];
    var midpoints = [], meanVals = [], ciLowVals = [], ciHighVals = [];

    for (var wStart = gene.start; wStart + winSize - 1 <= gene.end; wStart += step) {
      var wEnd = wStart + winSize - 1;
      var midpoint = (wStart + wEnd) / 2;

      // Count syn/nonsyn sites in this window (all within this gene)
      var synSites = 0, nonsynSites = 0;
      var cdsOffset = wStart - gene.start;
      var firstCodon = Math.floor(cdsOffset / 3);
      var lastCodon = Math.floor((wEnd - gene.start) / 3);
      var nCodons = Math.floor(geneLen / 3);

      for (var ci = firstCodon; ci <= lastCodon && ci < nCodons; ci++) {
        var codonStart = gene.start + ci * 3;
        if (codonStart - 1 < 0 || codonStart + 2 > seq.length) continue;
        var codon = seq.substring(codonStart - 1, codonStart + 2).toUpperCase();
        var refAA = CODON_TABLE[codon];
        if (!refAA) continue;

        for (var p = 0; p < 3; p++) {
          var sitePos = codonStart + p;
          if (sitePos < wStart || sitePos > wEnd) continue;
          var synC = 0, nonsynC = 0;
          var origBase = codon[p];
          for (var bi = 0; bi < 4; bi++) {
            var nb = BASES[bi];
            if (nb === origBase) continue;
            var mc = codon.substring(0, p) + nb + codon.substring(p + 1);
            var mAA = CODON_TABLE[mc];
            if (!mAA) continue;
            if (mAA === refAA) synC++; else nonsynC++;
          }
          synSites += synC / 3;
          nonsynSites += nonsynC / 3;
        }
      }

      if (synSites === 0 || nonsynSites === 0) continue;

      // Per-sample dN/dS for this window
      var dndsValues = [];
      for (var si = 0; si < sampleNames.length; si++) {
        var vars = sampleMap[sampleNames[si]];
        if (!vars) continue;
        var pS = 0, pN = 0;
        for (var vi = 0; vi < vars.length; vi++) {
          var vv = vars[vi];
          if (vv.pos < wStart || vv.pos > wEnd) continue;
          if (vv.type === 'syn') pS++;
          else if (vv.type === 'nonsyn') pN++;
        }
        var dS = pS / synSites;
        var dN = pN / nonsynSites;
        if (dS === 0) continue;
        dndsValues.push(dN / dS);
      }

      if (dndsValues.length === 0) continue;

      var mean = 0;
      for (var k = 0; k < dndsValues.length; k++) mean += dndsValues[k];
      mean /= dndsValues.length;

      var se = 0;
      if (dndsValues.length > 1) {
        var variance = 0;
        for (var k = 0; k < dndsValues.length; k++) variance += (dndsValues[k] - mean) * (dndsValues[k] - mean);
        variance /= (dndsValues.length - 1);
        se = Math.sqrt(variance / dndsValues.length);
      }

      midpoints.push(midpoint);
      meanVals.push(mean);
      ciLowVals.push(Math.max(0, mean - 1.96 * se));
      ciHighVals.push(mean + 1.96 * se);
    }

    if (midpoints.length === 0) continue;
    hasData = true;

    // CI band (upper then lower with fill) + mean line, per gene
    traces.push({
      x: midpoints, y: ciHighVals, type: 'scatter', mode: 'lines',
      line: { width: 0 }, showlegend: false, hoverinfo: 'skip'
    });
    // Parse gene color to rgba for fill
    var fillAlpha = '0.12';
    var rgbMatch = geneColor.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
    var fillColor = rgbMatch
      ? 'rgba(' + parseInt(rgbMatch[1],16) + ',' + parseInt(rgbMatch[2],16) + ',' + parseInt(rgbMatch[3],16) + ',' + fillAlpha + ')'
      : 'rgba(91,141,239,0.12)';
    traces.push({
      x: midpoints, y: ciLowVals, type: 'scatter', mode: 'lines',
      line: { width: 0 }, fill: 'tonexty', fillcolor: fillColor,
      showlegend: false, hoverinfo: 'skip'
    });
    traces.push({
      x: midpoints, y: meanVals, type: 'scatter', mode: 'lines',
      line: { color: geneColor, width: 2 },
      showlegend: false,
      hovertemplate: gene.name + '<br>Position: %{x:.0f}<br>dN/dS: %{y:.3f}<extra></extra>'
    });

    // Subtle background shading for gene region
    geneShapes.push({
      type: 'rect', xref: 'x', yref: 'paper',
      x0: gene.start, x1: gene.end, y0: 0, y1: 1,
      fillcolor: 'rgba(255,255,255,0.03)', line: { width: 0 }
    });
    // Gene label below the line segment
    geneAnnotations.push({
      x: (gene.start + gene.end) / 2, xref: 'x',
      y: 0, yref: 'paper', yanchor: 'top', yshift: -4,
      text: gene.name, showarrow: false,
      font: { color: geneColor, size: 10 }
    });
  }

  if (!hasData) {
    var plotDiv = document.getElementById('dnds-plot');
    Plotly.purge(plotDiv);
    plotDiv.innerHTML = '<div style="color:var(--text-dim); text-align:center; padding:80px 20px; font-size:14px;">Insufficient data for rolling window dN/dS (genes may be shorter than window size).</div>';
    dndsInitialized = false;
    return;
  }

  // Neutral line
  geneShapes.push({
    type: 'line', xref: 'paper', x0: 0, x1: 1,
    yref: 'y', y0: 1, y1: 1,
    line: { color: '#f0c040', width: 2, dash: 'dash' }
  });
  geneAnnotations.push({
    x: 1, xref: 'paper', xanchor: 'right',
    y: 1, yref: 'y', yanchor: 'bottom',
    text: 'neutral (dN/dS = 1)', showarrow: false,
    font: { color: '#f0c040', size: 10 }
  });

  var genomeLen = state.genomeLength || seq.length;
  var layout = {
    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
    font: { color: '#e0e0e8', family: '-apple-system, BlinkMacSystemFont, sans-serif' },
    xaxis: { title: 'Genome Position (nt)', range: [1, genomeLen], gridcolor: 'rgba(255,255,255,0.05)', zerolinecolor: 'rgba(255,255,255,0.1)' },
    yaxis: { title: 'dN/dS', gridcolor: 'rgba(255,255,255,0.05)', zerolinecolor: 'rgba(255,255,255,0.1)', rangemode: 'tozero' },
    margin: { t: 30, b: 80, l: 60, r: 20 },
    showlegend: false,
    shapes: geneShapes,
    annotations: geneAnnotations
  };
  var config = { responsive: true, displayModeBar: true, displaylogo: false };

  if (!dndsInitialized) {
    Plotly.newPlot('dnds-plot', traces, layout, config);
    dndsInitialized = true;
  } else {
    Plotly.react('dnds-plot', traces, layout, config);
  }
}

// ============================================================
// INIT
// ============================================================
// Colorblind mode: restore from localStorage and wire toggle
try {
  if (localStorage.getItem('variscient-colorblind') === '1') {
    applyColorblindPalette(true);
  }
} catch(e) {}
document.getElementById('cb-toggle').addEventListener('click', toggleColorblindMode);

initTable();
initEmptyPlot();
updateHistogram();
</script>
</body>
</html>
